"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[1939],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var r=a.createContext({}),d=function(e){var n=a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(r.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,r=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=d(t),h=i,c=m["".concat(r,".").concat(h)]||m[h]||u[h]||l;return t?a.createElement(c,s(s({ref:n},p),{},{components:t})):a.createElement(c,s({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,s=new Array(l);s[0]=m;var o={};for(var r in n)hasOwnProperty.call(n,r)&&(o[r]=n[r]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var d=2;d<l;d++)s[d]=t[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},46612:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=t(87462),i=(t(67294),t(3905));const l={sidebar_position:1},s="x/slashing",o={unversionedId:"modules/slashing/README",id:"modules/slashing/README",title:"x/slashing",description:"Abstract",source:"@site/docs/modules/slashing/README.md",sourceDirName:"modules/slashing",slug:"/modules/slashing/",permalink:"/main/modules/slashing/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"x/params",permalink:"/main/modules/params/"},next:{title:"x/staking",permalink:"/main/modules/staking/"}},r={},d=[{value:"Abstract",id:"abstract",level:2},{value:"Contents",id:"contents",level:2},{value:"Concepts",id:"concepts",level:2},{value:"States",id:"states",level:3},{value:"Tombstone Caps",id:"tombstone-caps",level:3},{value:"Infraction Timelines",id:"infraction-timelines",level:3},{value:"Single Double Sign Infraction",id:"single-double-sign-infraction",level:4},{value:"Multiple Double Sign Infractions",id:"multiple-double-sign-infractions",level:4},{value:"State",id:"state",level:2},{value:"Signing Info (Liveness)",id:"signing-info-liveness",level:3},{value:"Params",id:"params",level:3},{value:"Messages",id:"messages",level:2},{value:"Unjail",id:"unjail",level:3},{value:"BeginBlock",id:"beginblock",level:2},{value:"Liveness Tracking",id:"liveness-tracking",level:3},{value:"Hooks",id:"hooks",level:2},{value:"Staking hooks",id:"staking-hooks",level:3},{value:"Validator Bonded",id:"validator-bonded",level:3},{value:"Events",id:"events",level:2},{value:"MsgServer",id:"msgserver",level:3},{value:"MsgUnjail",id:"msgunjail",level:4},{value:"Keeper",id:"keeper",level:3},{value:"BeginBlocker: HandleValidatorSignature",id:"beginblocker-handlevalidatorsignature",level:3},{value:"Slash",id:"slash",level:4},{value:"Jail",id:"jail",level:4},{value:"Staking Tombstone",id:"staking-tombstone",level:2},{value:"Abstract",id:"abstract-1",level:3},{value:"Proposal: infinite jail",id:"proposal-infinite-jail",level:4},{value:"Single slashing amount",id:"single-slashing-amount",level:4},{value:"Parameters",id:"parameters",level:2},{value:"CLI",id:"cli",level:2},{value:"Query",id:"query",level:3},{value:"params",id:"params-1",level:4},{value:"signing-info",id:"signing-info",level:4},{value:"signing-infos",id:"signing-infos",level:4},{value:"Transactions",id:"transactions",level:3},{value:"unjail",id:"unjail-1",level:4},{value:"gRPC",id:"grpc",level:3},{value:"Params",id:"params-2",level:4},{value:"SigningInfo",id:"signinginfo",level:4},{value:"SigningInfos",id:"signinginfos",level:4},{value:"REST",id:"rest",level:3},{value:"Params",id:"params-3",level:4},{value:"signing_info",id:"signing_info",level:4},{value:"signing_infos",id:"signing_infos",level:4}],p={toc:d};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"xslashing"},(0,i.kt)("inlineCode",{parentName:"h1"},"x/slashing")),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"This section specifies the slashing module of the Cosmos SDK, which implements functionality\nfirst outlined in the ",(0,i.kt)("a",{parentName:"p",href:"https://cosmos.network/about/whitepaper"},"Cosmos Whitepaper")," in June 2016."),(0,i.kt)("p",null,'The slashing module enables Cosmos SDK-based blockchains to disincentivize any attributable action\nby a protocol-recognized actor with value at stake by penalizing them ("slashing").'),(0,i.kt)("p",null,"Penalties may include, but are not limited to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Burning some amount of their stake"),(0,i.kt)("li",{parentName:"ul"},"Removing their ability to vote on future blocks for a period of time.")),(0,i.kt)("p",null,"This module will be used by the Cosmos Hub, the first hub in the Cosmos ecosystem."),(0,i.kt)("h2",{id:"contents"},"Contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#concepts"},"Concepts"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#states"},"States")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#tombstone-caps"},"Tombstone Caps")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#infraction-timelines"},"Infraction Timelines")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#state"},"State"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#signing-info-liveness"},"Signing Info (Liveness)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#params"},"Params")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#messages"},"Messages"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#unjail"},"Unjail")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#beginblock"},"BeginBlock"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#liveness-tracking"},"Liveness Tracking")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#hooks"},"Hooks")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#events"},"Events")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#staking-tombstone"},"Staking Tombstone")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameters"},"Parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#cli"},"CLI"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#query"},"Query")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#transactions"},"Transactions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#grpc"},"gRPC")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#rest"},"REST"))))),(0,i.kt)("h2",{id:"concepts"},"Concepts"),(0,i.kt)("h3",{id:"states"},"States"),(0,i.kt)("p",null,"At any given time, there are any number of validators registered in the state\nmachine. Each block, the top ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxValidators")," (defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"x/staking"),") validators\nwho are not jailed become ",(0,i.kt)("em",{parentName:"p"},"bonded"),", meaning that they may propose and vote on\nblocks. Validators who are ",(0,i.kt)("em",{parentName:"p"},"bonded")," are ",(0,i.kt)("em",{parentName:"p"},"at stake"),", meaning that part or all of\ntheir stake and their delegators' stake is at risk if they commit a protocol fault."),(0,i.kt)("p",null,"For each of these validators we keep a ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatorSigningInfo")," record that contains\ninformation partaining to validator's liveness and other infraction related\nattributes."),(0,i.kt)("h3",{id:"tombstone-caps"},"Tombstone Caps"),(0,i.kt)("p",null,"In order to mitigate the impact of initially likely categories of non-malicious\nprotocol faults, the Cosmos Hub implements for each validator\na ",(0,i.kt)("em",{parentName:"p"},"tombstone")," cap, which only allows a validator to be slashed once for a double\nsign fault. For example, if you misconfigure your HSM and double-sign a bunch of\nold blocks, you'll only be punished for the first double-sign (and then immediately tombstombed). This will still be quite expensive and desirable to avoid, but tombstone caps\nsomewhat blunt the economic impact of unintentional misconfiguration."),(0,i.kt)("p",null,'Liveness faults do not have caps, as they can\'t stack upon each other. Liveness bugs are "detected" as soon as the infraction occurs, and the validators are immediately put in jail, so it is not possible for them to commit multiple liveness faults without unjailing in between.'),(0,i.kt)("h3",{id:"infraction-timelines"},"Infraction Timelines"),(0,i.kt)("p",null,"To illustrate how the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/slashing")," module handles submitted evidence through\nCometBFT consensus, consider the following examples:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Definitions"),":"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"[")," : timeline start",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"]")," : timeline end",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"C",(0,i.kt)("sub",null,"n"))," : infraction ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," committed",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"D",(0,i.kt)("sub",null,"n"))," : infraction ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," discovered",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"V",(0,i.kt)("sub",null,"b"))," : validator bonded",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("em",{parentName:"p"},"V",(0,i.kt)("sub",null,"u"))," : validator unbonded"),(0,i.kt)("h4",{id:"single-double-sign-infraction"},"Single Double Sign Infraction"),(0,i.kt)("p",null,"[","----------C",(0,i.kt)("sub",null,"1"),"----D",(0,i.kt)("sub",null,"1"),",V",(0,i.kt)("sub",null,"u"),"-----","]"),(0,i.kt)("p",null,"A single infraction is committed then later discovered, at which point the\nvalidator is unbonded and slashed at the full amount for the infraction."),(0,i.kt)("h4",{id:"multiple-double-sign-infractions"},"Multiple Double Sign Infractions"),(0,i.kt)("p",null,"[","----------C",(0,i.kt)("sub",null,"1"),"--C",(0,i.kt)("sub",null,"2"),"---C",(0,i.kt)("sub",null,"3"),"---D",(0,i.kt)("sub",null,"1"),",D",(0,i.kt)("sub",null,"2"),",D",(0,i.kt)("sub",null,"3"),"V",(0,i.kt)("sub",null,"u"),"-----","]"),(0,i.kt)("p",null,"Multiple infractions are committed and then later discovered, at which point the\nvalidator is jailed and slashed for only one infraction. Because the validator\nis also tombstoned, they can not rejoin the validator set."),(0,i.kt)("h2",{id:"state"},"State"),(0,i.kt)("h3",{id:"signing-info-liveness"},"Signing Info (Liveness)"),(0,i.kt)("p",null,"Every block includes a set of precommits by the validators for the previous block,\nknown as the ",(0,i.kt)("inlineCode",{parentName:"p"},"LastCommitInfo")," provided by CometBFT. A ",(0,i.kt)("inlineCode",{parentName:"p"},"LastCommitInfo")," is valid so\nlong as it contains precommits from +2/3 of total voting power."),(0,i.kt)("p",null,"Proposers are incentivized to include precommits from all validators in the CometBFT ",(0,i.kt)("inlineCode",{parentName:"p"},"LastCommitInfo"),"\nby receiving additional fees proportional to the difference between the voting\npower included in the ",(0,i.kt)("inlineCode",{parentName:"p"},"LastCommitInfo")," and +2/3 (see ",(0,i.kt)("a",{parentName:"p",href:"/main/modules/distribution/#begin-block"},"fee distribution"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type LastCommitInfo struct {\n    Round int32\n    Votes []VoteInfo\n}\n")),(0,i.kt)("p",null,"Validators are penalized for failing to be included in the ",(0,i.kt)("inlineCode",{parentName:"p"},"LastCommitInfo")," for some\nnumber of blocks by being automatically jailed, potentially slashed, and unbonded."),(0,i.kt)("p",null,"Information about validator's liveness activity is tracked through ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatorSigningInfo"),".\nIt is indexed in the store as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"ValidatorSigningInfo: ",(0,i.kt)("inlineCode",{parentName:"li"},"0x01 | ConsAddrLen (1 byte) | ConsAddress -> ProtocolBuffer(ValSigningInfo)")),(0,i.kt)("li",{parentName:"ul"},"MissedBlocksBitArray: ",(0,i.kt)("inlineCode",{parentName:"li"},"0x02 | ConsAddrLen (1 byte) | ConsAddress | LittleEndianUint64(signArrayIndex) -> VarInt(didMiss)")," (varint is a number encoding format)")),(0,i.kt)("p",null,"The first mapping allows us to easily lookup the recent signing info for a\nvalidator based on the validator's consensus address."),(0,i.kt)("p",null,"The second mapping (",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksBitArray"),") acts\nas a bit-array of size ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlocksWindow")," that tells us if the validator missed\nthe block for a given index in the bit-array. The index in the bit-array is given\nas little endian uint64.\nThe result is a ",(0,i.kt)("inlineCode",{parentName:"p"},"varint")," that takes on ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," indicates the\nvalidator did not miss (did sign) the corresponding block, and ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," indicates\nthey missed the block (did not sign)."),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksBitArray")," is not explicitly initialized up-front. Keys\nare added as we progress through the first ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlocksWindow")," blocks for a newly\nbonded validator. The ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlocksWindow")," parameter defines the size\n(number of blocks) of the sliding window used to track validator liveness."),(0,i.kt)("p",null,"The information stored for tracking validator liveness is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:"reference",reference:!0},"https://github.com/cosmos/cosmos-sdk/blob/v0.47.0-rc1/proto/cosmos/slashing/v1beta1/slashing.proto#L13-L35\n")),(0,i.kt)("h3",{id:"params"},"Params"),(0,i.kt)("p",null,"The slashing module stores it's params in state with the prefix of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00"),",\nit can be updated with governance or the address with authority."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Params: ",(0,i.kt)("inlineCode",{parentName:"li"},"0x00 | ProtocolBuffer(Params)"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:"reference",reference:!0},"https://github.com/cosmos/cosmos-sdk/blob/v0.47.0-rc1/proto/cosmos/slashing/v1beta1/slashing.proto#L37-L59\n")),(0,i.kt)("h2",{id:"messages"},"Messages"),(0,i.kt)("p",null,"In this section we describe the processing of messages for the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module."),(0,i.kt)("h3",{id:"unjail"},"Unjail"),(0,i.kt)("p",null,"If a validator was automatically unbonded due to downtime and wishes to come back online &\npossibly rejoin the bonded set, it must send ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgUnjail"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"// MsgUnjail is an sdk.Msg used for unjailing a jailed validator, thus returning\n// them into the bonded validator set, so they can begin receiving provisions\n// and rewards again.\nmessage MsgUnjail {\n  string validator_addr = 1;\n}\n")),(0,i.kt)("p",null,"Below is a pseudocode of the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSrv/Unjail")," RPC:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'unjail(tx MsgUnjail)\n    validator = getValidator(tx.ValidatorAddr)\n    if validator == nil\n      fail with "No validator found"\n\n    if getSelfDelegation(validator) == 0\n      fail with "validator must self delegate before unjailing"\n\n    if !validator.Jailed\n      fail with "Validator not jailed, cannot unjail"\n\n    info = GetValidatorSigningInfo(operator)\n    if info.Tombstoned\n      fail with "Tombstoned validator cannot be unjailed"\n    if block time < info.JailedUntil\n      fail with "Validator still jailed, cannot unjail until period has expired"\n\n    validator.Jailed = false\n    setValidator(validator)\n\n    return\n')),(0,i.kt)("p",null,"If the validator has enough stake to be in the top ",(0,i.kt)("inlineCode",{parentName:"p"},"n = MaximumBondedValidators"),", it will be automatically rebonded,\nand all delegators still delegated to the validator will be rebonded and begin to again collect\nprovisions and rewards."),(0,i.kt)("h2",{id:"beginblock"},"BeginBlock"),(0,i.kt)("h3",{id:"liveness-tracking"},"Liveness Tracking"),(0,i.kt)("p",null,"At the beginning of each block, we update the ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatorSigningInfo")," for each\nvalidator and check if they've crossed below the liveness threshold over a\nsliding window. This sliding window is defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlocksWindow")," and the\nindex in this window is determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexOffset")," found in the validator's\n",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatorSigningInfo"),". For each block processed, the ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexOffset")," is incremented\nregardless if the validator signed or not. Once the index is determined, the\n",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksBitArray")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksCounter")," are updated accordingly."),(0,i.kt)("p",null,"Finally, in order to determine if a validator crosses below the liveness threshold,\nwe fetch the maximum number of blocks missed, ",(0,i.kt)("inlineCode",{parentName:"p"},"maxMissed"),", which is\n",(0,i.kt)("inlineCode",{parentName:"p"},"SignedBlocksWindow - (MinSignedPerWindow * SignedBlocksWindow)")," and the minimum\nheight at which we can determine liveness, ",(0,i.kt)("inlineCode",{parentName:"p"},"minHeight"),". If the current block is\ngreater than ",(0,i.kt)("inlineCode",{parentName:"p"},"minHeight")," and the validator's ",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksCounter")," is greater than\n",(0,i.kt)("inlineCode",{parentName:"p"},"maxMissed"),", they will be slashed by ",(0,i.kt)("inlineCode",{parentName:"p"},"SlashFractionDowntime"),", will be jailed\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"DowntimeJailDuration"),", and have the following values reset:\n",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksBitArray"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MissedBlocksCounter"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexOffset"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": Liveness slashes do ",(0,i.kt)("strong",{parentName:"p"},"NOT")," lead to a tombstombing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"height := block.Height\n\nfor vote in block.LastCommitInfo.Votes {\n  signInfo := GetValidatorSigningInfo(vote.Validator.Address)\n\n  // This is a relative index, so we counts blocks the validator SHOULD have\n  // signed. We use the 0-value default signing info if not present, except for\n  // start height.\n  index := signInfo.IndexOffset % SignedBlocksWindow()\n  signInfo.IndexOffset++\n\n  // Update MissedBlocksBitArray and MissedBlocksCounter. The MissedBlocksCounter\n  // just tracks the sum of MissedBlocksBitArray. That way we avoid needing to\n  // read/write the whole array each time.\n  missedPrevious := GetValidatorMissedBlockBitArray(vote.Validator.Address, index)\n  missed := !signed\n\n  switch {\n  case !missedPrevious && missed:\n    // array index has changed from not missed to missed, increment counter\n    SetValidatorMissedBlockBitArray(vote.Validator.Address, index, true)\n    signInfo.MissedBlocksCounter++\n\n  case missedPrevious && !missed:\n    // array index has changed from missed to not missed, decrement counter\n    SetValidatorMissedBlockBitArray(vote.Validator.Address, index, false)\n    signInfo.MissedBlocksCounter--\n\n  default:\n    // array index at this index has not changed; no need to update counter\n  }\n\n  if missed {\n    // emit events...\n  }\n\n  minHeight := signInfo.StartHeight + SignedBlocksWindow()\n  maxMissed := SignedBlocksWindow() - MinSignedPerWindow()\n\n  // If we are past the minimum height and the validator has missed too many\n  // jail and slash them.\n  if height > minHeight && signInfo.MissedBlocksCounter > maxMissed {\n    validator := ValidatorByConsAddr(vote.Validator.Address)\n\n    // emit events...\n\n    // We need to retrieve the stake distribution which signed the block, so we\n    // subtract ValidatorUpdateDelay from the block height, and subtract an\n    // additional 1 since this is the LastCommit.\n    //\n    // Note, that this CAN result in a negative \"distributionHeight\" up to\n    // -ValidatorUpdateDelay-1, i.e. at the end of the pre-genesis block (none) = at the beginning of the genesis block.\n    // That's fine since this is just used to filter unbonding delegations & redelegations.\n    distributionHeight := height - sdk.ValidatorUpdateDelay - 1\n\n    SlashWithInfractionReason(vote.Validator.Address, distributionHeight, vote.Validator.Power, SlashFractionDowntime(), stakingtypes.Downtime)\n    Jail(vote.Validator.Address)\n\n    signInfo.JailedUntil = block.Time.Add(DowntimeJailDuration())\n\n    // We need to reset the counter & array so that the validator won't be\n    // immediately slashed for downtime upon rebonding.\n    signInfo.MissedBlocksCounter = 0\n    signInfo.IndexOffset = 0\n    ClearValidatorMissedBlockBitArray(vote.Validator.Address)\n  }\n\n  SetValidatorSigningInfo(vote.Validator.Address, signInfo)\n}\n")),(0,i.kt)("h2",{id:"hooks"},"Hooks"),(0,i.kt)("p",null,"This section contains a description of the module's ",(0,i.kt)("inlineCode",{parentName:"p"},"hooks"),". Hooks are operations that are executed automatically when events are raised."),(0,i.kt)("h3",{id:"staking-hooks"},"Staking hooks"),(0,i.kt)("p",null,"The slashing module implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"StakingHooks")," defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"x/staking")," and are used as record-keeping of validators information. During the app initialization, these hooks should be registered in the staking module struct."),(0,i.kt)("p",null,"The following hooks impact the slashing state:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AfterValidatorBonded")," creates a ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidatorSigningInfo")," instance as described in the following section."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AfterValidatorCreated")," stores a validator's consensus key."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AfterValidatorRemoved")," removes a validator's consensus key.")),(0,i.kt)("h3",{id:"validator-bonded"},"Validator Bonded"),(0,i.kt)("p",null,"Upon successful first-time bonding of a new validator, we create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidatorSigningInfo")," structure for the\nnow-bonded validator, which ",(0,i.kt)("inlineCode",{parentName:"p"},"StartHeight")," of the current block."),(0,i.kt)("p",null,"If the validator was out of the validator set and gets bonded again, its new bonded height is set."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"onValidatorBonded(address sdk.ValAddress)\n\n  signingInfo, found = GetValidatorSigningInfo(address)\n  if !found {\n    signingInfo = ValidatorSigningInfo {\n      StartHeight         : CurrentHeight,\n      IndexOffset         : 0,\n      JailedUntil         : time.Unix(0, 0),\n      Tombstone           : false,\n      MissedBloskCounter  : 0\n    } else {\n      signingInfo.StartHeight = CurrentHeight\n    }\n\n    setValidatorSigningInfo(signingInfo)\n  }\n\n  return\n")),(0,i.kt)("h2",{id:"events"},"Events"),(0,i.kt)("p",null,"The slashing module emits the following events:"),(0,i.kt)("h3",{id:"msgserver"},"MsgServer"),(0,i.kt)("h4",{id:"msgunjail"},"MsgUnjail"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"message"),(0,i.kt)("td",{parentName:"tr",align:null},"module"),(0,i.kt)("td",{parentName:"tr",align:null},"slashing")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"message"),(0,i.kt)("td",{parentName:"tr",align:null},"sender"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorAddress}")))),(0,i.kt)("h3",{id:"keeper"},"Keeper"),(0,i.kt)("h3",{id:"beginblocker-handlevalidatorsignature"},"BeginBlocker: HandleValidatorSignature"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"address"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorConsensusAddress}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"power"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorPower}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"reason"),(0,i.kt)("td",{parentName:"tr",align:null},"{slashReason}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"jailed ","[0]"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorConsensusAddress}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"burned coins"),(0,i.kt)("td",{parentName:"tr",align:null},"{math.Int}")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"[0]"," Only included if the validator is jailed.")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liveness"),(0,i.kt)("td",{parentName:"tr",align:null},"address"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorConsensusAddress}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liveness"),(0,i.kt)("td",{parentName:"tr",align:null},"missed_blocks"),(0,i.kt)("td",{parentName:"tr",align:null},"{missedBlocksCounter}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liveness"),(0,i.kt)("td",{parentName:"tr",align:null},"height"),(0,i.kt)("td",{parentName:"tr",align:null},"{blockHeight}")))),(0,i.kt)("h4",{id:"slash"},"Slash"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"same as ",(0,i.kt)("inlineCode",{parentName:"li"},'"slash"')," event from ",(0,i.kt)("inlineCode",{parentName:"li"},"HandleValidatorSignature"),", but without the ",(0,i.kt)("inlineCode",{parentName:"li"},"jailed")," attribute.")),(0,i.kt)("h4",{id:"jail"},"Jail"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"slash"),(0,i.kt)("td",{parentName:"tr",align:null},"jailed"),(0,i.kt)("td",{parentName:"tr",align:null},"{validatorAddress}")))),(0,i.kt)("h2",{id:"staking-tombstone"},"Staking Tombstone"),(0,i.kt)("h3",{id:"abstract-1"},"Abstract"),(0,i.kt)("p",null,"In the current implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing"),' module, when the consensus engine\ninforms the state machine of a validator\'s consensus fault, the validator is\npartially slashed, and put into a "jail period", a period of time in which they\nare not allowed to rejoin the validator set. However, because of the nature of\nconsensus faults and ABCI, there can be a delay between an infraction occurring,\nand evidence of the infraction reaching the state machine (this is one of the\nprimary reasons for the existence of the unbonding period).'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: The tombstone concept, only applies to faults that have a delay between\nthe infraction occurring and evidence reaching the state machine. For example,\nevidence of a validator double signing may take a while to reach the state machine\ndue to unpredictable evidence gossip layer delays and the ability of validators to\nselectively reveal double-signatures (e.g. to infrequently-online light clients).\nLiveness slashing, on the other hand, is detected immediately as soon as the\ninfraction occurs, and therefore no slashing period is needed. A validator is\nimmediately put into jail period, and they cannot commit another liveness fault\nuntil they unjail. In the future, there may be other types of byzantine faults\nthat have delays (for example, submitting evidence of an invalid proposal as a transaction).\nWhen implemented, it will have to be decided whether these future types of\nbyzantine faults will result in a tombstoning (and if not, the slash amounts\nwill not be capped by a slashing period).")),(0,i.kt)("p",null,"In the current system design, once a validator is put in the jail for a consensus\nfault, after the ",(0,i.kt)("inlineCode",{parentName:"p"},"JailPeriod")," they are allowed to send a transaction to ",(0,i.kt)("inlineCode",{parentName:"p"},"unjail"),"\nthemselves, and thus rejoin the validator set."),(0,i.kt)("p",null,'One of the "design desires" of the ',(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module is that if multiple\ninfractions occur before evidence is executed (and a validator is put in jail),\nthey should only be punished for single worst infraction, but not cumulatively.\nFor example, if the sequence of events is:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Validator A commits Infraction 1 (worth 30% slash)"),(0,i.kt)("li",{parentName:"ol"},"Validator A commits Infraction 2 (worth 40% slash)"),(0,i.kt)("li",{parentName:"ol"},"Validator A commits Infraction 3 (worth 35% slash)"),(0,i.kt)("li",{parentName:"ol"},"Evidence for Infraction 1 reaches state machine (and validator is put in jail)"),(0,i.kt)("li",{parentName:"ol"},"Evidence for Infraction 2 reaches state machine"),(0,i.kt)("li",{parentName:"ol"},"Evidence for Infraction 3 reaches state machine")),(0,i.kt)("p",null,"Only Infraction 2 should have its slash take effect, as it is the highest. This\nis done, so that in the case of the compromise of a validator's consensus key,\nthey will only be punished once, even if the hacker double-signs many blocks.\nBecause, the unjailing has to be done with the validator's operator key, they\nhave a chance to re-secure their consensus key, and then signal that they are\nready using their operator key. We call this period during which we track only\nthe max infraction, the \"slashing period\"."),(0,i.kt)("p",null,"Once, a validator rejoins by unjailing themselves, we begin a new slashing period;\nif they commit a new infraction after unjailing, it gets slashed cumulatively on\ntop of the worst infraction from the previous slashing period."),(0,i.kt)("p",null,"However, while infractions are grouped based off of the slashing periods, because\nevidence can be submitted up to an ",(0,i.kt)("inlineCode",{parentName:"p"},"unbondingPeriod")," after the infraction, we\nstill have to allow for evidence to be submitted for previous slashing periods.\nFor example, if the sequence of events is:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Validator A commits Infraction 1 (worth 30% slash)"),(0,i.kt)("li",{parentName:"ol"},"Validator A commits Infraction 2 (worth 40% slash)"),(0,i.kt)("li",{parentName:"ol"},"Evidence for Infraction 1 reaches state machine (and Validator A is put in jail)"),(0,i.kt)("li",{parentName:"ol"},"Validator A unjails")),(0,i.kt)("p",null,"We are now in a new slashing period, however we still have to keep the door open\nfor the previous infraction, as the evidence for Infraction 2 may still come in.\nAs the number of slashing periods increase, it creates more complexity as we have\nto keep track of the highest infraction amount for every single slashing period."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Currently, according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module spec, a new slashing period\nis created every time a validator is unbonded then rebonded. This should probably\nbe changed to jailed/unjailed. See issue ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/issues/3205"},"#3205"),"\nfor further details. For the remainder of this, I will assume that we only start\na new slashing period when a validator gets unjailed.")),(0,i.kt)("p",null,"The maximum number of slashing periods is the ",(0,i.kt)("inlineCode",{parentName:"p"},"len(UnbondingPeriod) / len(JailPeriod)"),".\nThe current defaults in Gaia for the ",(0,i.kt)("inlineCode",{parentName:"p"},"UnbondingPeriod")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"JailPeriod")," are 3 weeks\nand 2 days, respectively. This means there could potentially be up to 11 slashing\nperiods concurrently being tracked per validator. If we set the ",(0,i.kt)("inlineCode",{parentName:"p"},"JailPeriod >= UnbondingPeriod"),",\nwe only have to track 1 slashing period (i.e not have to track slashing periods)."),(0,i.kt)("p",null,'Currently, in the jail period implementation, once a validator unjails, all of\ntheir delegators who are delegated to them (haven\'t unbonded / redelegated away),\nstay with them. Given that consensus safety faults are so egregious\n(way more so than liveness faults), it is probably prudent to have delegators not\n"auto-rebond" to the validator.'),(0,i.kt)("h4",{id:"proposal-infinite-jail"},"Proposal: infinite jail"),(0,i.kt)("p",null,'We propose setting the "jail time" for a\nvalidator who commits a consensus safety fault, to ',(0,i.kt)("inlineCode",{parentName:"p"},"infinite"),' (i.e. a tombstone state).\nThis essentially kicks the validator out of the validator set and does not allow\nthem to re-enter the validator set. All of their delegators (including the operator themselves)\nhave to either unbond or redelegate away. The validator operator can create a new\nvalidator if they would like, with a new operator key and consensus key, but they\nhave to "re-earn" their delegations back.'),(0,i.kt)("p",null,"Implementing the tombstone system and getting rid of the slashing period tracking\nwill make the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module way simpler, especially because we can remove all\nof the hooks defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module consumed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"staking")," module\n(the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module still consumes hooks defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"staking"),")."),(0,i.kt)("h4",{id:"single-slashing-amount"},"Single slashing amount"),(0,i.kt)("p",null,"Another optimization that can be made is that if we assume that all ABCI faults\nfor CometBFT consensus are slashed at the same level, we don't have to keep\ntrack of \"max slash\". Once an ABCI fault happens, we don't have to worry about\ncomparing potential future ones to find the max."),(0,i.kt)("p",null,"Currently the only CometBFT ABCI fault is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unjustified precommits (double signs)")),(0,i.kt)("p",null,"It is currently planned to include the following fault in the near future:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Signing a precommit when you're in unbonding phase (needed to make light client bisection safe)")),(0,i.kt)("p",null,"Given that these faults are both attributable byzantine faults, we will likely\nwant to slash them equally, and thus we can enact the above change."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: This change may make sense for current CometBFT consensus, but maybe\nnot for a different consensus algorithm or future versions of CometBFT that\nmay want to punish at different levels (for example, partial slashing).")),(0,i.kt)("h2",{id:"parameters"},"Parameters"),(0,i.kt)("p",null,"The slashing module contains the following parameters:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Key"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Example"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SignedBlocksWindow"),(0,i.kt)("td",{parentName:"tr",align:null},"string (int64)"),(0,i.kt)("td",{parentName:"tr",align:null},'"100"')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MinSignedPerWindow"),(0,i.kt)("td",{parentName:"tr",align:null},"string (dec)"),(0,i.kt)("td",{parentName:"tr",align:null},'"0.500000000000000000"')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DowntimeJailDuration"),(0,i.kt)("td",{parentName:"tr",align:null},"string (ns)"),(0,i.kt)("td",{parentName:"tr",align:null},'"600000000000"')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SlashFractionDoubleSign"),(0,i.kt)("td",{parentName:"tr",align:null},"string (dec)"),(0,i.kt)("td",{parentName:"tr",align:null},'"0.050000000000000000"')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SlashFractionDowntime"),(0,i.kt)("td",{parentName:"tr",align:null},"string (dec)"),(0,i.kt)("td",{parentName:"tr",align:null},'"0.010000000000000000"')))),(0,i.kt)("h2",{id:"cli"},"CLI"),(0,i.kt)("p",null,"A user can query and interact with the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module using the CLI."),(0,i.kt)("h3",{id:"query"},"Query"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," commands allow users to query ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing --help\n")),(0,i.kt)("h4",{id:"params-1"},"params"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"params")," command allows users to query genesis parameters for the slashing module."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing params [flags]\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing params\n")),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yml"},'downtime_jail_duration: 600s\nmin_signed_per_window: "0.500000000000000000"\nsigned_blocks_window: "100"\nslash_fraction_double_sign: "0.050000000000000000"\nslash_fraction_downtime: "0.010000000000000000"\n')),(0,i.kt)("h4",{id:"signing-info"},"signing-info"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"signing-info")," command allows users to query signing-info of the validator using consensus public key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing signing-infos [flags]\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'simd query slashing signing-info \'{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Auxs3865HpB/EfssYOzfqNhEJjzys6jD5B6tPgC8="}\'\n\n')),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yml"},'address: cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\nindex_offset: "2068"\njailed_until: "1970-01-01T00:00:00Z"\nmissed_blocks_counter: "0"\nstart_height: "0"\ntombstoned: false\n')),(0,i.kt)("h4",{id:"signing-infos"},"signing-infos"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"signing-infos")," command allows users to query signing infos of all validators."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing signing-infos [flags]\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"simd query slashing signing-infos\n")),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yml"},'info:\n- address: cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c\n  index_offset: "2075"\n  jailed_until: "1970-01-01T00:00:00Z"\n  missed_blocks_counter: "0"\n  start_height: "0"\n  tombstoned: false\npagination:\n  next_key: null\n  total: "0"\n')),(0,i.kt)("h3",{id:"transactions"},"Transactions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"tx")," commands allow users to interact with the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"simd tx slashing --help\n")),(0,i.kt)("h4",{id:"unjail-1"},"unjail"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"unjail")," command allows users to unjail a validator previously jailed for downtime."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"simd tx slashing unjail --from mykey [flags]\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"simd tx slashing unjail --from mykey\n")),(0,i.kt)("h3",{id:"grpc"},"gRPC"),(0,i.kt)("p",null,"A user can query the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module using gRPC endpoints."),(0,i.kt)("h4",{id:"params-2"},"Params"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Params")," endpoint allows users to query the parameters of slashing module."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cosmos.slashing.v1beta1.Query/Params\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"grpcurl -plaintext localhost:9090 cosmos.slashing.v1beta1.Query/Params\n")),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "params": {\n    "signedBlocksWindow": "100",\n    "minSignedPerWindow": "NTAwMDAwMDAwMDAwMDAwMDAw",\n    "downtimeJailDuration": "600s",\n    "slashFractionDoubleSign": "NTAwMDAwMDAwMDAwMDAwMDA=",\n    "slashFractionDowntime": "MTAwMDAwMDAwMDAwMDAwMDA="\n  }\n}\n')),(0,i.kt)("h4",{id:"signinginfo"},"SigningInfo"),(0,i.kt)("p",null,"The SigningInfo queries the signing info of given cons address."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cosmos.slashing.v1beta1.Query/SigningInfo\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'grpcurl -plaintext -d \'{"cons_address":"cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c"}\' localhost:9090 cosmos.slashing.v1beta1.Query/SigningInfo\n')),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "valSigningInfo": {\n    "address": "cosmosvalcons1nrqsld3aw6lh6t082frdqc84uwxn0t958c",\n    "indexOffset": "3493",\n    "jailedUntil": "1970-01-01T00:00:00Z"\n  }\n}\n')),(0,i.kt)("h4",{id:"signinginfos"},"SigningInfos"),(0,i.kt)("p",null,"The SigningInfos queries signing info of all validators."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cosmos.slashing.v1beta1.Query/SigningInfos\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"grpcurl -plaintext localhost:9090 cosmos.slashing.v1beta1.Query/SigningInfos\n")),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "info": [\n    {\n      "address": "cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c",\n      "indexOffset": "2467",\n      "jailedUntil": "1970-01-01T00:00:00Z"\n    }\n  ],\n  "pagination": {\n    "total": "1"\n  }\n}\n')),(0,i.kt)("h3",{id:"rest"},"REST"),(0,i.kt)("p",null,"A user can query the ",(0,i.kt)("inlineCode",{parentName:"p"},"slashing")," module using REST endpoints."),(0,i.kt)("h4",{id:"params-3"},"Params"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"/cosmos/slashing/v1beta1/params\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'curl "localhost:1317/cosmos/slashing/v1beta1/params"\n')),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "params": {\n    "signed_blocks_window": "100",\n    "min_signed_per_window": "0.500000000000000000",\n    "downtime_jail_duration": "600s",\n    "slash_fraction_double_sign": "0.050000000000000000",\n    "slash_fraction_downtime": "0.010000000000000000"\n}\n')),(0,i.kt)("h4",{id:"signing_info"},"signing_info"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"/cosmos/slashing/v1beta1/signing_infos/%s\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'curl "localhost:1317/cosmos/slashing/v1beta1/signing_infos/cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c"\n')),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "val_signing_info": {\n    "address": "cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c",\n    "start_height": "0",\n    "index_offset": "4184",\n    "jailed_until": "1970-01-01T00:00:00Z",\n    "tombstoned": false,\n    "missed_blocks_counter": "0"\n  }\n}\n')),(0,i.kt)("h4",{id:"signing_infos"},"signing_infos"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"/cosmos/slashing/v1beta1/signing_infos\n")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'curl "localhost:1317/cosmos/slashing/v1beta1/signing_infos\n')),(0,i.kt)("p",null,"Example Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "info": [\n    {\n      "address": "cosmosvalcons1nrqslkwd3pz096lh6t082frdqc84uwxn0t958c",\n      "start_height": "0",\n      "index_offset": "4169",\n      "jailed_until": "1970-01-01T00:00:00Z",\n      "tombstoned": false,\n      "missed_blocks_counter": "0"\n    }\n  ],\n  "pagination": {\n    "next_key": null,\n    "total": "1"\n  }\n}\n')))}u.isMDXComponent=!0}}]);