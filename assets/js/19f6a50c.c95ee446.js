"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[9334],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(n),u=i,h=m["".concat(l,".").concat(u)]||m[u]||c[u]||a;return n?o.createElement(h,r(r({ref:t},p),{},{components:n})):o.createElement(h,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<a;d++)r[d]=n[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},73789:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=n(87462),i=(n(67294),n(3905));const a={},r="ADR 054: Semver Compatible SDK Modules",s={unversionedId:"architecture/adr-054-semver-compatible-modules",id:"version-v0.50/architecture/adr-054-semver-compatible-modules",title:"ADR 054: Semver Compatible SDK Modules",description:"Changelog",source:"@site/versioned_docs/version-v0.50/architecture/adr-054-semver-compatible-modules.md",sourceDirName:"architecture",slug:"/architecture/adr-054-semver-compatible-modules",permalink:"/v0.50/architecture/adr-054-semver-compatible-modules",draft:!1,tags:[],version:"v0.50",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ADR 053: Go Module Refactoring",permalink:"/v0.50/architecture/adr-053-go-module-refactoring"},next:{title:"ADR 055: ORM",permalink:"/v0.50/architecture/adr-055-orm"}},l={},d=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Problem 1: Semantic Import Versioning Compatibility",id:"problem-1-semantic-import-versioning-compatibility",level:3},{value:"Scenario A: Backward Compatibility: Newer Foo, Older Bar",id:"scenario-a-backward-compatibility-newer-foo-older-bar",level:4},{value:"Scenario B: Forward Compatibility: Older Foo, Newer Bar",id:"scenario-b-forward-compatibility-older-foo-newer-bar",level:4},{value:"Naive Mitigation",id:"naive-mitigation",level:4},{value:"Problem 2: Circular dependencies",id:"problem-2-circular-dependencies",level:3},{value:"Problem 3: Handling Minor Version Incompatibilities",id:"problem-3-handling-minor-version-incompatibilities",level:3},{value:"Solutions",id:"solutions",level:2},{value:"Approach A) Separate API and State Machine Modules",id:"approach-a-separate-api-and-state-machine-modules",level:3},{value:"Migrate all interface methods on API types to handlers",id:"migrate-all-interface-methods-on-api-types-to-handlers",level:4},{value:"Pinned FileDescriptor&#39;s",id:"pinned-filedescriptors",level:4},{value:"Potential limitations to generated code",id:"potential-limitations-to-generated-code",level:4},{value:"Minor Version Incompatibilities",id:"minor-version-incompatibilities",level:4},{value:"Approach B) Changes to Generated Code",id:"approach-b-changes-to-generated-code",level:3},{value:"Approach C) Don&#39;t address these issues",id:"approach-c-dont-address-these-issues",level:3},{value:"Approach D) Avoid protobuf generated code in public APIs",id:"approach-d-avoid-protobuf-generated-code-in-public-apis",level:3},{value:"Decision",id:"decision",level:2},{value:"Minor API Revisions",id:"minor-api-revisions",level:3},{value:"Introspecting Minor API Revisions",id:"introspecting-minor-api-revisions",level:3},{value:"Unknown Field Filtering",id:"unknown-field-filtering",level:3},{value:"<code>FileDescriptor</code> Registration",id:"filedescriptor-registration",level:3},{value:"Module Dependency Declaration",id:"module-dependency-declaration",level:3},{value:"Interface Registration",id:"interface-registration",level:3},{value:"Testing",id:"testing",level:3},{value:"Unit Testing",id:"unit-testing",level:4},{value:"Integration Testing",id:"integration-testing",level:4},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"References",id:"references",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adr-054-semver-compatible-sdk-modules"},"ADR 054: Semver Compatible SDK Modules"),(0,i.kt)("h2",{id:"changelog"},"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-04-27: First draft")),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"DRAFT"),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"In order to move the Cosmos SDK to a system of decoupled semantically versioned\nmodules which can be composed in different combinations (ex. staking v3 with\nbank v1 and distribution v2), we need to reassess how we organize the API surface\nof modules to avoid problems with go semantic import versioning and\ncircular dependencies. This ADR explores various approaches we can take to\naddressing these issues."),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,"There has been ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/discussions/10162"},"a fair amount of desire"),"\nin the community for semantic versioning in the SDK and there has been significant\nmovement to splitting SDK modules into ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/issues/11899"},"standalone go modules"),".\nBoth of these will ideally allow the ecosystem to move faster because we won't\nbe waiting for all dependencies to update synchronously. For instance, we could\nhave 3 versions of the core SDK compatible with the latest 2 releases of\nCosmWasm as well as 4 different versions of staking . This sort of setup would\nallow early adopters to aggressively integrate new versions, while allowing\nmore conservative users to be selective about which versions they're ready for."),(0,i.kt)("p",null,"In order to achieve this, we need to solve the following problems:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"because of the way ",(0,i.kt)("a",{parentName:"li",href:"https://research.swtch.com/vgo-import"},"go semantic import versioning")," (SIV)\nworks, moving to SIV naively will actually make it harder to achieve these goals"),(0,i.kt)("li",{parentName:"ol"},"circular dependencies between modules need to be broken to actually release\nmany modules in the SDK independently"),(0,i.kt)("li",{parentName:"ol"},"pernicious minor version incompatibilities introduced through correctly\n",(0,i.kt)("a",{parentName:"li",href:"https://developers.google.com/protocol-buffers/docs/proto3#updating"},"evolving protobuf schemas"),"\nwithout correct ",(0,i.kt)("a",{parentName:"li",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"))),(0,i.kt)("p",null,"Note that all the following discussion assumes that the proto file versioning and state machine versioning of a module\nare distinct in that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"proto files are maintained in a non-breaking way (using something\nlike ",(0,i.kt)("a",{parentName:"li",href:"https://docs.buf.build/breaking/overview"},"buf breaking"),"\nto ensure all changes are backwards compatible)"),(0,i.kt)("li",{parentName:"ul"},"proto file versions get bumped much less frequently, i.e. we might maintain ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmos.bank.v1")," through many versions\nof the bank module state machine"),(0,i.kt)("li",{parentName:"ul"},"state machine breaking changes are more common and ideally this is what we'd want to semantically version with\ngo modules, ex. ",(0,i.kt)("inlineCode",{parentName:"li"},"x/bank/v2"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x/bank/v3"),", etc.")),(0,i.kt)("h3",{id:"problem-1-semantic-import-versioning-compatibility"},"Problem 1: Semantic Import Versioning Compatibility"),(0,i.kt)("p",null,"Consider we have a module ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," which defines the following ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," and that we've released its state\nmachine in go module ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"package foo.v1;\n\nmessage MsgDoSomething {\n  string sender = 1;\n  uint64 amount = 2;\n}\n\nservice Msg {\n  DoSomething(MsgDoSomething) returns (MsgDoSomethingResponse);\n}\n")),(0,i.kt)("p",null,"Now consider that we make a revision to this module and add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," field to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," and also\nadd a new validation rule on ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," requiring it to be non-zero, and that following go semantic versioning we\nrelease the next state machine version of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"// Revision 1\npackage foo.v1;\n\nmessage MsgDoSomething {\n  string sender = 1;\n  \n  // amount must be a non-zero integer.\n  uint64 amount = 2;\n  \n  // condition is an optional condition on doing the thing.\n  //\n  // Since: Revision 1\n  Condition condition = 3;\n}\n")),(0,i.kt)("p",null,"Approaching this naively, we would generate the protobuf types for the initial\nversion of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types")," and we would generate the protobuf\ntypes for the second version in ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types"),"."),(0,i.kt)("p",null,"Now let's say we have a module ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," which talks to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," using this keeper\ninterface which ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," provides:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type FooKeeper interface {\n    DoSomething(MsgDoSomething) error\n}\n")),(0,i.kt)("h4",{id:"scenario-a-backward-compatibility-newer-foo-older-bar"},"Scenario A: Backward Compatibility: Newer Foo, Older Bar"),(0,i.kt)("p",null,"Imagine we have a chain which uses both ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," and wants to upgrade to\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", but the ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," module has not upgraded to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"."),(0,i.kt)("p",null,"In this case, the chain will not be able to upgrade to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," until ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"\nhas upgraded its references to ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types.MsgDoSomething")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething"),"."),(0,i.kt)("p",null,"Even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"'s usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," has not changed at all, the upgrade\nwill be impossible without this change because ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types.MsgDoSomething"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething")," are fundamentally different\nincompatible structs in the go type system."),(0,i.kt)("h4",{id:"scenario-b-forward-compatibility-older-foo-newer-bar"},"Scenario B: Forward Compatibility: Older Foo, Newer Bar"),(0,i.kt)("p",null,"Now let's consider the reverse scenario, where ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," upgrades to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"\nby changing the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething"),"\nand releases that as ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," with some other changes that a chain wants.\nThe chain, however, has decided that it thinks the changes in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," are too\nrisky and that it'd prefer to stay on the initial version of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,i.kt)("p",null,"In this scenario, it is impossible to upgrade to ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," without upgrading\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," would have worked 100% fine with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," other\nthan changing the import path to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," (meaning that ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2"),"\ndoesn't actually use any new features of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),")."),(0,i.kt)("p",null,"Now because of the way go semantic import versioning works, we are locked\ninto either using ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," OR ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2"),". We cannot have\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," OR ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),". The go type system doesn't allow this\neven if both versions of these modules are otherwise compatible with each\nother."),(0,i.kt)("h4",{id:"naive-mitigation"},"Naive Mitigation"),(0,i.kt)("p",null,"A naive approach to fixing this would be to not regenerate the protobuf types\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types")," but instead just update ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types"),"\nto reflect the changes needed for ",(0,i.kt)("inlineCode",{parentName:"p"},"v2")," (adding ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," and requiring\n",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," to be non-zero). Then we could release a patch of ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types"),"\nwith this update and use that for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),". But this change is state machine\nbreaking for ",(0,i.kt)("inlineCode",{parentName:"p"},"v1"),". It requires changing the ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateBasic")," method to reject\nthe case where ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," is zero, and it adds the ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," field which\nshould be rejected based\non ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"ADR 020 unknown field filtering"),".\nSo adding these changes as a patch on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," is actually incorrect based on semantic\nversioning. Chains that want to stay on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," should not\nbe importing these changes because they are incorrect for ",(0,i.kt)("inlineCode",{parentName:"p"},"v1.")),(0,i.kt)("h3",{id:"problem-2-circular-dependencies"},"Problem 2: Circular dependencies"),(0,i.kt)("p",null,"None of the above approaches allow ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," to be separate modules\nif for some reason ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," depend on each other in different ways.\nFor instance, we can't have ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," import ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/types")," while ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," imports\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/types"),"."),(0,i.kt)("p",null,"We have several cases of circular module dependencies in the SDK\n(ex. staking, distribution and slashing) that are legitimate from a state machine\nperspective. Without separating the API types out somehow, there would be\nno way to independently semantically version these modules without some other\nmitigation."),(0,i.kt)("h3",{id:"problem-3-handling-minor-version-incompatibilities"},"Problem 3: Handling Minor Version Incompatibilities"),(0,i.kt)("p",null,"Imagine that we solve the first two problems but now have a scenario where\n",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," wants the option to use ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething.condition")," which only ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"\nsupports. If ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," works with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," and sets ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," to some non-nil\nvalue, then ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," will silently ignore this field resulting in a silent logic\npossibly dangerous logic error. If ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," were able to check whether ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," was\non ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"v2")," and dynamically, it could choose to only use ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," when\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," is available. Even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," were able to perform this check, however,\nhow do we know that it is always performing the check properly. Without\nsome sort of\nframework-level ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),",\nit is hard to know whether these pernicious hard to detect bugs are getting into\nour app and a client-server layer such as ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033: Inter-Module Communication"),"\nmay be needed to do this."),(0,i.kt)("h2",{id:"solutions"},"Solutions"),(0,i.kt)("h3",{id:"approach-a-separate-api-and-state-machine-modules"},"Approach A) Separate API and State Machine Modules"),(0,i.kt)("p",null,"One solution (first proposed in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/discussions/10582"},"https://github.com/cosmos/cosmos-sdk/discussions/10582"),") is to isolate all protobuf\ngenerated code into a separate module\nfrom the state machine module. This would mean that we could have state machine\ngo modules ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," which could use a types or API go module say\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api"),". This ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," go module would be perpetually on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1.x")," and only\naccept non-breaking changes. This would then allow other modules to be\ncompatible with either ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," as long as the inter-module API only\ndepends on the types in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api"),". It would also allow modules ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"\nto depend on each other in that both of them could depend on ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"bar/api")," without ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," directly depending on ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," and vice versa."),(0,i.kt)("p",null,"This is similar to the naive mitigation described above except that it separates\nthe types into separate go modules which in and of itself could be used to\nbreak circular module dependencies. It has the same problems as the naive solution,\notherwise, which we could rectify by:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"removing all state machine breaking code from the API module (ex. ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidateBasic")," and any other interface methods)"),(0,i.kt)("li",{parentName:"ol"},"embedding the correct file descriptors for unknown field filtering in the binary")),(0,i.kt)("h4",{id:"migrate-all-interface-methods-on-api-types-to-handlers"},"Migrate all interface methods on API types to handlers"),(0,i.kt)("p",null,"To solve 1), we need to remove all interface implementations from generated\ntypes and instead use a handler approach which essentially means that given\na type ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", we have some sort of resolver which allows us to resolve interface\nimplementations for that type (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"authz.Authorization"),"). For\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) DoSomething(msg MsgDoSomething) error {\n    var validateBasicHandler ValidateBasicHandler\n    err := k.resolver.Resolve(&validateBasic, msg)\n    if err != nil {\n        return err\n    }   \n    \n    err = validateBasicHandler.ValidateBasic()\n    ...\n}\n")),(0,i.kt)("p",null,"In the case of some methods on ",(0,i.kt)("inlineCode",{parentName:"p"},"sdk.Msg"),", we could replace them with declarative\nannotations. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"GetSigners")," can already be replaced by the protobuf\nannotation ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmos.msg.v1.signer"),". In the future, we may consider some sort\nof protobuf validation framework (like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bufbuild/protoc-gen-validate"},"https://github.com/bufbuild/protoc-gen-validate"),"\nbut more Cosmos-specific) to replace ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateBasic"),"."),(0,i.kt)("h4",{id:"pinned-filedescriptors"},"Pinned FileDescriptor's"),(0,i.kt)("p",null,"To solve 2), state machine modules must be able to specify what the version of\nthe protobuf files was that they were built against. For instance if the API\nmodule for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," upgrades to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", the original ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," module still needs\na copy of the original protobuf files it was built with so that ADR 020\nunknown field filtering will reject ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," when ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," is\nset."),(0,i.kt)("p",null,"The simplest way to do this may be to embed the protobuf ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s into\nthe module itself so that these ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s are used at runtime rather\nthan the ones that are built into the ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," which may be different. Using\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.buf.build/build/usage#output-format"},"buf build"),", ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/embed"},"go embed"),",\nand a build script we can probably come up with a solution for embedding\n",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s into modules that is fairly straightforward."),(0,i.kt)("h4",{id:"potential-limitations-to-generated-code"},"Potential limitations to generated code"),(0,i.kt)("p",null,"One challenge with this approach is that it places heavy restrictions on what\ncan go in API modules and requires that most of this is state machine breaking.\nAll or most of the code in the API module would be generated from protobuf\nfiles, so we can probably control this with how code generation is done, but\nit is a risk to be aware of."),(0,i.kt)("p",null,"For instance, we do code generation for the ORM that in the future could\ncontain optimizations that are state machine breaking. We\nwould either need to ensure very carefully that the optimizations aren't\nactually state machine breaking in generated code or separate this generated code\nout from the API module into the state machine module. Both of these mitigations\nare potentially viable but the API module approach does require an extra level\nof care to avoid these sorts of issues."),(0,i.kt)("h4",{id:"minor-version-incompatibilities"},"Minor Version Incompatibilities"),(0,i.kt)("p",null,"This approach in and of itself does little to address any potential minor\nversion incompatibilities and the\nrequisite ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),".\nLikely some sort of client-server routing layer which does this check such as\n",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033: Inter-Module communication"),"\nis required to make sure that this is done properly. We could then allow\nmodules to perform a runtime check given a ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgClient"),", ex:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) CallFoo() error {\n    if k.interModuleClient.MinorRevision(k.fooMsgClient) >= 2 {\n        k.fooMsgClient.DoSomething(&MsgDoSomething{Condition: ...})\n    } else {\n        ...\n    }\n}\n")),(0,i.kt)("p",null,"To do the unknown field filtering itself, the ADR 033 router would need to use\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect"},"protoreflect API"),"\nto ensure that no fields unknown to the receiving module are set. This could\nresult in an undesirable performance hit depending on how complex this logic is."),(0,i.kt)("h3",{id:"approach-b-changes-to-generated-code"},"Approach B) Changes to Generated Code"),(0,i.kt)("p",null,"An alternate approach to solving the versioning problem is to change how protobuf code is generated and move modules\nmostly or completely in the direction of inter-module communication as described\nin ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"),".\nIn this paradigm, a module could generate all the types it needs internally - including the API types of other modules -\nand talk to other modules via a client-server boundary. For instance, if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," needs to talk to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", it could\ngenerate its own version of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/internal/foo/v1.MsgDoSomething")," and just pass this to the\ninter-module router which would somehow convert it to the version which foo needs (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/internal.MsgDoSomething"),")."),(0,i.kt)("p",null,"Currently, two generated structs for the same protobuf type cannot exist in the same go binary without special\nbuild flags (see ",(0,i.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers/docs/reference/go/faq#fix-namespace-conflict"},"https://developers.google.com/protocol-buffers/docs/reference/go/faq#fix-namespace-conflict"),").\nA relatively simple mitigation to this issue would be to set up the protobuf code to not register protobuf types\nglobally if they are generated in an ",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," package. This will require modules to register their types manually\nwith the app-level level protobuf registry, this is similar to what modules already do with the ",(0,i.kt)("inlineCode",{parentName:"p"},"InterfaceRegistry"),"\nand amino codec."),(0,i.kt)("p",null,"If modules ",(0,i.kt)("em",{parentName:"p"},"only")," do ADR 033 message passing then a naive and non-performant solution for\nconverting ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/internal/foo/v1.MsgDoSomething"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/internal.MsgDoSomething")," would be marshaling and unmarshaling in the ADR 033 router. This would break down if\nwe needed to expose protobuf types in ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," interfaces because the whole point is to try to keep these types\n",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," so that we don't end up with all the import version incompatibilities we've described above. However,\nbecause of the issue with minor version incompatibilities and the need\nfor ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),",\nsticking with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," paradigm instead of ADR 033 may be unviable to begin with."),(0,i.kt)("p",null,"A more performant solution (that could maybe be adapted to work with ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," interfaces) would be to only expose\ngetters and setters for generated types and internally store data in memory buffers which could be passed from\none implementation to another in a zero-copy way."),(0,i.kt)("p",null,"For example, imagine this protobuf API with only getters and setters is exposed for ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type MsgSend interface {\n    proto.Message\n    GetFromAddress() string\n    GetToAddress() string\n    GetAmount() []v1beta1.Coin\n    SetFromAddress(string)\n    SetToAddress(string)\n    SetAmount([]v1beta1.Coin)\n}\n\nfunc NewMsgSend() MsgSend { return &msgSendImpl{memoryBuffers: ...} }\n")),(0,i.kt)("p",null,"Under the hood, ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend")," could be implemented based on some raw memory buffer in the same way\nthat ",(0,i.kt)("a",{parentName:"p",href:"https://capnproto.org"},"Cap'n Proto"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://google.github.io/flatbuffers/"},"FlatBuffers")," so that we could convert between one version of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend"),"\nand another without serialization (i.e. zero-copy). This approach would have the added benefits of allowing zero-copy\nmessage passing to modules written in other languages such as Rust and accessed through a VM or FFI. It could also make\nunknown field filtering in inter-module communication simpler if we require that all new fields are added in sequential\norder, ex. just checking that no field ",(0,i.kt)("inlineCode",{parentName:"p"},"> 5")," is set."),(0,i.kt)("p",null,"Also, we wouldn't have any issues with state machine breaking code on generated types because all the generated\ncode used in the state machine would actually live in the state machine module itself. Depending on how interface\ntypes and protobuf ",(0,i.kt)("inlineCode",{parentName:"p"},"Any"),"s are used in other languages, however, it may still be desirable to take the handler\napproach described in approach A. Either way, types implementing interfaces would still need to be registered\nwith an ",(0,i.kt)("inlineCode",{parentName:"p"},"InterfaceRegistry")," as they are now because there would be no way to retrieve them via the global registry."),(0,i.kt)("p",null,"In order to simplify access to other modules using ADR 033, a public API module (maybe even one\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.buf.build/bsr/remote-generation/go"},"remotely generated by Buf"),") could be used by client modules instead\nof requiring to generate all client types internally."),(0,i.kt)("p",null,"The big downsides of this approach are that it requires big changes to how people use protobuf types and would be a\nsubstantial rewrite of the protobuf code generator. This new generated code, however, could still be made compatible\nwith\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect"},(0,i.kt)("inlineCode",{parentName:"a"},"google.golang.org/protobuf/reflect/protoreflect")),"\nAPI in order to work with all standard golang protobuf tooling."),(0,i.kt)("p",null,"It is possible that the naive approach of marshaling/unmarshaling in the ADR 033 router is an acceptable intermediate\nsolution if the changes to the code generator are seen as too complex. However, since all modules would likely need\nto migrate to ADR 033 anyway with this approach, it might be better to do this all at once."),(0,i.kt)("h3",{id:"approach-c-dont-address-these-issues"},"Approach C) Don't address these issues"),(0,i.kt)("p",null,"If the above solutions are seen as too complex, we can also decide not to do anything explicit to enable better module\nversion compatibility, and break circular dependencies."),(0,i.kt)("p",null,"In this case, when developers are confronted with the issues described above they can require dependencies to update in\nsync (what we do now) or attempt some ad-hoc potentially hacky solution."),(0,i.kt)("p",null,"One approach is to ditch go semantic import versioning (SIV) altogether. Some people have commented that go's SIV\n(i.e. changing the import path to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v3"),", etc.) is too restrictive and that it should be optional. The\ngolang maintainers disagree and only officially support semantic import versioning. We could, however, take the\ncontrarian perspective and get more flexibility by using 0.x-based versioning basically forever."),(0,i.kt)("p",null,"Module version compatibility could then be achieved using go.mod replace directives to pin dependencies to specific\ncompatible 0.x versions. For instance if we knew ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," 0.2 and 0.3 were both compatible with ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," 0.3 and 0.4, we\ncould use replace directives in our go.mod to stick to the versions of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," we want. This would work as\nlong as the authors of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," avoid incompatible breaking changes between these modules."),(0,i.kt)("p",null,"Or, if developers choose to use semantic import versioning, they can attempt the naive solution described above\nand would also need to use special tags and replace directives to make sure that modules are pinned to the correct\nversions."),(0,i.kt)("p",null,"Note, however, that all of these ad-hoc approaches, would be vulnerable to the minor version compatibility issues\ndescribed above unless ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),"\nis properly addressed."),(0,i.kt)("h3",{id:"approach-d-avoid-protobuf-generated-code-in-public-apis"},"Approach D) Avoid protobuf generated code in public APIs"),(0,i.kt)("p",null,"An alternative approach would be to avoid protobuf generated code in public module APIs. This would help avoid the\ndiscrepancy between state machine versions and client API versions at the module to module boundaries. It would mean\nthat we wouldn't do inter-module message passing based on ADR 033, but rather stick to the existing keeper approach\nand take it one step further by avoiding any protobuf generated code in the keeper interface methods."),(0,i.kt)("p",null,"Using this approach, our ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.Keeper.DoSomething")," method wouldn't have the generated ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," struct (which\ncomes from the protobuf API), but instead positional parameters. Then in order for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," to support the ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v1"),"\nkeeper it would simply need to implement both the v1 and v2 keeper APIs. The ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething")," method in v2 could have the\nadditional ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," parameter, but this wouldn't be present in v1 at all so there would be no danger of a client\naccidentally setting this when it isn't available. "),(0,i.kt)("p",null,"So this approach would avoid the challenge around minor version incompatibilities because the existing module keeper\nAPI would not get new fields when they are added to protobuf files."),(0,i.kt)("p",null,"Taking this approach, however, would likely require making all protobuf generated code internal in order to prevent\nit from leaking into the keeper API. This means we would still need to modify the protobuf code generator to not\nregister ",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," code with the global registry, and we would still need to manually register protobuf\n",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s (this is probably true in all scenarios). It may, however, be possible to avoid needing to refactor\ninterface methods on generated types to handlers."),(0,i.kt)("p",null,"Also, this approach doesn't address what would be done in scenarios where modules still want to use the message router.\nEither way, we probably still want a way to pass messages from one module to another router safely even if it's just for\nuse cases like ",(0,i.kt)("inlineCode",{parentName:"p"},"x/gov"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x/authz"),", CosmWasm, etc. That would still require most of the things outlined in approach (B),\nalthough we could advise modules to prefer keepers for communicating with other modules."),(0,i.kt)("p",null,"The biggest downside of this approach is probably that it requires a strict refactoring of keeper interfaces to avoid\ngenerated code leaking into the API. This may result in cases where we need to duplicate types that are already defined\nin proto files and then write methods for converting between the golang and protobuf version. This may end up in a lot\nof unnecessary boilerplate and that may discourage modules from actually adopting it and achieving effective version\ncompatibility. Approaches (A) and (B), although heavy handed initially, aim to provide a system which once adopted\nmore or less gives the developer version compatibility for free with minimal boilerplate. Approach (D) may not be able\nto provide such a straightforward system since it requires a golang API to be defined alongside a protobuf API in a\nway that requires duplication and differing sets of design principles (protobuf APIs encourage additive changes\nwhile golang APIs would forbid it)."),(0,i.kt)("p",null,"Other downsides to this approach are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"no clear roadmap to supporting modules in other languages like Rust"),(0,i.kt)("li",{parentName:"ul"},"doesn't get us any closer to proper object capability security (one of the goals of ADR 033)"),(0,i.kt)("li",{parentName:"ul"},"ADR 033 needs to be done properly anyway for the set of use cases which do need it")),(0,i.kt)("h2",{id:"decision"},"Decision"),(0,i.kt)("p",null,"The latest ",(0,i.kt)("strong",{parentName:"p"},"DRAFT")," proposal is:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"we are alignment on adopting ",(0,i.kt)("a",{parentName:"li",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033")," not just as an addition to the\nframework, but as a core replacement to the keeper paradigm entirely."),(0,i.kt)("li",{parentName:"ol"},"the ADR 033 inter-module router will accommodate any variation of approach (A) or (B) given the following rules:\na. if the client type is the same as the server type then pass it directly through,\nb. if both client and server use the zero-copy generated code wrappers (which still need to be defined), then pass\nthe memory buffers from one wrapper to the other, or\nc. marshal/unmarshal types between client and server.")),(0,i.kt)("p",null,"This approach will allow for both maximal correctness and enable a clear path to enabling modules within in other\nlanguages, possibly executed within a WASM VM."),(0,i.kt)("h3",{id:"minor-api-revisions"},"Minor API Revisions"),(0,i.kt)("p",null,"To declare minor API revisions of proto files, we propose the following guidelines (which were already documented\nin ",(0,i.kt)("a",{parentName:"p",href:"../proto/cosmos/app/v1alpha1/module.proto"},"cosmos.app.v1alpha module options"),"):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"proto packages which are revised from their initial version (considered revision ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),") should include a ",(0,i.kt)("inlineCode",{parentName:"li"},"package")),(0,i.kt)("li",{parentName:"ul"},"comment in some .proto file containing the test ",(0,i.kt)("inlineCode",{parentName:"li"},"Revision N")," at the start of a comment line where ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," is the current\nrevision number."),(0,i.kt)("li",{parentName:"ul"},"all fields, messages, etc. added in a version beyond the initial revision should add a comment at the start of a\ncomment line of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"Since: Revision N")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," is the non-zero revision it was added.")),(0,i.kt)("p",null,"It is advised that there is a 1:1 correspondence between a state machine module and versioned set of proto files\nwhich are versioned either as a buf module a go API module or both. If the buf schema registry is used, the version of\nthis buf module should always be ",(0,i.kt)("inlineCode",{parentName:"p"},"1.N")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," corresponds to the package revision. Patch releases should be used when\nonly documentation comments are updated. It is okay to include proto packages named ",(0,i.kt)("inlineCode",{parentName:"p"},"v2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"v3"),", etc. in this same\n",(0,i.kt)("inlineCode",{parentName:"p"},"1.N")," versioned buf module (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmos.bank.v2"),") as long as all these proto packages consist of a single API intended\nto be served by a single SDK module."),(0,i.kt)("h3",{id:"introspecting-minor-api-revisions"},"Introspecting Minor API Revisions"),(0,i.kt)("p",null,"In order for modules to introspect the minor API revision of peer modules, we propose adding the following method\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmossdk.io/core/intermodule.Client"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"ServiceRevision(ctx context.Context, serviceName string) uint64\n")),(0,i.kt)("p",null,"Modules could all this using the service name statically generated by the go grpc code generator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"intermoduleClient.ServiceRevision(ctx, bankv1beta1.Msg_ServiceDesc.ServiceName)\n")),(0,i.kt)("p",null,"In the future, we may decide to extend the code generator used for protobuf services to add a field\nto client types which does this check more concisely, ex:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"package bankv1beta1\n\ntype MsgClient interface {\n    Send(context.Context, MsgSend) (MsgSendResponse, error)\n    ServiceRevision(context.Context) uint64\n}\n")),(0,i.kt)("h3",{id:"unknown-field-filtering"},"Unknown Field Filtering"),(0,i.kt)("p",null,"To correctly perform ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),",\nthe inter-module router can do one of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"use the ",(0,i.kt)("inlineCode",{parentName:"li"},"protoreflect")," API for messages which support that"),(0,i.kt)("li",{parentName:"ul"},"for gogo proto messages, marshal and use the existing ",(0,i.kt)("inlineCode",{parentName:"li"},"codec/unknownproto")," code"),(0,i.kt)("li",{parentName:"ul"},"for zero-copy messages, do a simple check on the highest set field number (assuming we can require that fields are\nadding consecutively in increasing order)")),(0,i.kt)("h3",{id:"filedescriptor-registration"},(0,i.kt)("inlineCode",{parentName:"h3"},"FileDescriptor")," Registration"),(0,i.kt)("p",null,"Because a single go binary may contain different versions of the same generated protobuf code, we cannot rely on the\nglobal protobuf registry to contain the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s. Because ",(0,i.kt)("inlineCode",{parentName:"p"},"appconfig")," module configuration is itself\nwritten in protobuf, we would like to load the ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s for a module before loading a module itself. So we\nwill provide ways to register ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s at module registration time before instantiation. We propose the\nfollowing ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmossdk.io/core/appmodule.Option")," constructors for the various cases of how ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s may be\npackaged:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"package appmodule\n\n// this can be used when we are using google.golang.org/protobuf compatible generated code\n// Ex:\n//   ProtoFiles(bankv1beta1.File_cosmos_bank_v1beta1_module_proto)\nfunc ProtoFiles(file []protoreflect.FileDescriptor) Option {}\n\n// this can be used when we are using gogo proto generated code.\nfunc GzippedProtoFiles(file [][]byte) Option {}\n\n// this can be used when we are using buf build to generated a pinned file descriptor\nfunc ProtoImage(protoImage []byte) Option {}\n")),(0,i.kt)("p",null,"This approach allows us to support several ways protobuf files might be generated:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"proto files generated internally to a module (use ",(0,i.kt)("inlineCode",{parentName:"li"},"ProtoFiles"),")"),(0,i.kt)("li",{parentName:"ul"},"the API module approach with pinned file descriptors (use ",(0,i.kt)("inlineCode",{parentName:"li"},"ProtoImage"),")"),(0,i.kt)("li",{parentName:"ul"},"gogo proto (use ",(0,i.kt)("inlineCode",{parentName:"li"},"GzippedProtoFiles"),")")),(0,i.kt)("h3",{id:"module-dependency-declaration"},"Module Dependency Declaration"),(0,i.kt)("p",null,"One risk of ADR 033 is that dependencies are called at runtime which are not present in the loaded set of SDK modules.",(0,i.kt)("br",{parentName:"p"}),"\n","Also we want modules to have a way to define a minimum dependency API revision that they require. Therefore, all\nmodules should declare their set of dependencies upfront. These dependencies could be defined when a module is\ninstantiated, but ideally we know what the dependencies are before instantiation and can statically look at an app\nconfig and determine whether the set of modules. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," revision ",(0,i.kt)("inlineCode",{parentName:"p"},">= 1"),", then we\nshould be able to know this when creating an app config with two versions of ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,i.kt)("p",null,"We propose defining these dependencies in the proto options of the module config object itself."),(0,i.kt)("h3",{id:"interface-registration"},"Interface Registration"),(0,i.kt)("p",null,"We will also need to define how interface methods are defined on types that are serialized as ",(0,i.kt)("inlineCode",{parentName:"p"},"google.protobuf.Any"),"'s.\nIn light of the desire to support modules in other languages, we may want to think of solutions that will accommodate\nother languages such as plugins described briefly in ",(0,i.kt)("a",{parentName:"p",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm#internal-methods"},"ADR 033"),"."),(0,i.kt)("h3",{id:"testing"},"Testing"),(0,i.kt)("p",null,"In order to ensure that modules are indeed with multiple versions of their dependencies, we plan to provide specialized\nunit and integration testing infrastructure that automatically tests multiple versions of dependencies."),(0,i.kt)("h4",{id:"unit-testing"},"Unit Testing"),(0,i.kt)("p",null,"Unit tests should be conducted inside SDK modules by mocking their dependencies. In a full ADR 033 scenario,\nthis means that all interaction with other modules is done via the inter-module router, so mocking of dependencies\nmeans mocking their msg and query server implementations. We will provide both a test runner and fixture to make this\nstreamlined. The key thing that the test runner should do to test compatibility is to test all combinations of\ndependency API revisions. This can be done by taking the file descriptors for the dependencies, parsing their comments\nto determine the revisions various elements were added, and then created synthetic file descriptors for each revision\nby subtracting elements that were added later."),(0,i.kt)("p",null,"Here is a proposed API for the unit test runner and fixture:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package moduletesting\n\nimport (\n    "context"\n    "testing"\n\n    "cosmossdk.io/core/intermodule"\n    "cosmossdk.io/depinject"\n    "google.golang.org/grpc"\n    "google.golang.org/protobuf/proto"\n    "google.golang.org/protobuf/reflect/protodesc"\n)\n\ntype TestFixture interface {\n    context.Context\n    intermodule.Client // for making calls to the module we\'re testing\n    BeginBlock()\n    EndBlock()\n}\n\ntype UnitTestFixture interface {\n    TestFixture\n    grpc.ServiceRegistrar // for registering mock service implementations\n}\n\ntype UnitTestConfig struct {\n    ModuleConfig              proto.Message    // the module\'s config object\n    DepinjectConfig           depinject.Config // optional additional depinject config options\n    DependencyFileDescriptors []protodesc.FileDescriptorProto // optional dependency file descriptors to use instead of the global registry\n}\n\n// Run runs the test function for all combinations of dependency API revisions.\nfunc (cfg UnitTestConfig) Run(t *testing.T, f func(t *testing.T, f UnitTestFixture)) {\n    // ...\n}\n')),(0,i.kt)("p",null,"Here is an example for testing bar calling foo which takes advantage of conditional service revisions in the expected\nmock arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func TestBar(t *testing.T) {\n    UnitTestConfig{ModuleConfig: &foomodulev1.Module{}}.Run(t, func (t *testing.T, f moduletesting.UnitTestFixture) {\n        ctrl := gomock.NewController(t)\n        mockFooMsgServer := footestutil.NewMockMsgServer()\n        foov1.RegisterMsgServer(f, mockFooMsgServer)\n        barMsgClient := barv1.NewMsgClient(f)\n        if f.ServiceRevision(foov1.Msg_ServiceDesc.ServiceName) >= 1 {\n            mockFooMsgServer.EXPECT().DoSomething(gomock.Any(), &foov1.MsgDoSomething{\n                ...,\n                Condition: ..., // condition is expected in revision >= 1\n            }).Return(&foov1.MsgDoSomethingResponse{}, nil)\n        } else {\n            mockFooMsgServer.EXPECT().DoSomething(gomock.Any(), &foov1.MsgDoSomething{...}).Return(&foov1.MsgDoSomethingResponse{}, nil)\n        }\n        res, err := barMsgClient.CallFoo(f, &MsgCallFoo{})\n        ...\n    })\n}\n")),(0,i.kt)("p",null,"The unit test runner would make sure that no dependency mocks return arguments which are invalid for the service\nrevision being tested to ensure that modules don't incorrectly depend on functionality not present in a given revision."),(0,i.kt)("h4",{id:"integration-testing"},"Integration Testing"),(0,i.kt)("p",null,"An integration test runner and fixture would also be provided which instead of using mocks would test actual module\ndependencies in various combinations. Here is the proposed API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type IntegrationTestFixture interface {\n    TestFixture\n}\n\ntype IntegrationTestConfig struct {\n    ModuleConfig     proto.Message    // the module's config object\n    DependencyMatrix map[string][]proto.Message // all the dependent module configs\n}\n\n// Run runs the test function for all combinations of dependency modules.\nfunc (cfg IntegationTestConfig) Run(t *testing.T, f func (t *testing.T, f IntegrationTestFixture)) {\n    // ...\n}\n")),(0,i.kt)("p",null,"And here is an example with foo and bar:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func TestBarIntegration(t *testing.T) {\n    IntegrationTestConfig{\n        ModuleConfig: &barmodulev1.Module{},\n        DependencyMatrix: map[string][]proto.Message{\n            "runtime": []proto.Message{ // test against two versions of runtime\n                &runtimev1.Module{},\n                &runtimev2.Module{},\n            },\n            "foo": []proto.Message{ // test against three versions of foo\n                &foomodulev1.Module{},\n                &foomodulev2.Module{},\n                &foomodulev3.Module{},\n            }\n        }   \n    }.Run(t, func (t *testing.T, f moduletesting.IntegrationTestFixture) {\n        barMsgClient := barv1.NewMsgClient(f)\n        res, err := barMsgClient.CallFoo(f, &MsgCallFoo{})\n        ...\n    })\n}\n')),(0,i.kt)("p",null,"Unlike unit tests, integration tests actually pull in other module dependencies. So that modules can be written\nwithout direct dependencies on other modules and because golang has no concept of development dependencies, integration\ntests should be written in separate go modules, ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/bar/v2/test"),". Because this paradigm uses go semantic\nversioning, it is possible to build a single go module which imports 3 versions of bar and 2 versions of runtime and\ncan test these all together in the six various combinations of dependencies."),(0,i.kt)("h2",{id:"consequences"},"Consequences"),(0,i.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,i.kt)("p",null,"Modules which migrate fully to ADR 033 will not be compatible with existing modules which use the keeper paradigm.\nAs a temporary workaround we may create some wrapper types that emulate the current keeper interface to minimize\nthe migration overhead."),(0,i.kt)("h3",{id:"positive"},"Positive"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"we will be able to deliver interoperable semantically versioned modules which should dramatically increase the\nability of the Cosmos SDK ecosystem to iterate on new features"),(0,i.kt)("li",{parentName:"ul"},"it will be possible to write Cosmos SDK modules in other languages in the near future")),(0,i.kt)("h3",{id:"negative"},"Negative"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"all modules will need to be refactored somewhat dramatically")),(0,i.kt)("h3",{id:"neutral"},"Neutral"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmossdk.io/core/appconfig")," framework will play a more central role in terms of how modules are defined, this\nis likely generally a good thing but does mean additional changes for users wanting to stick to the pre-depinject way\nof wiring up modules"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depinject")," is somewhat less needed or maybe even obviated because of the full ADR 033 approach. If we adopt the\ncore API proposed in ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/pull/12239"},"https://github.com/cosmos/cosmos-sdk/pull/12239"),", then a module would probably always instantiate\nitself with a method ",(0,i.kt)("inlineCode",{parentName:"li"},"ProvideModule(appmodule.Service) (appmodule.AppModule, error)"),". There is no complex wiring of\nkeeper dependencies in this scenario and dependency injection may not have as much of (or any) use case.")),(0,i.kt)("h2",{id:"further-discussions"},"Further Discussions"),(0,i.kt)("p",null,"The decision described above is considered in draft mode and is pending final buy-in from the team and key stakeholders.\nKey outstanding discussions if we do adopt that direction are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"how do module clients introspect dependency module API revisions"),(0,i.kt)("li",{parentName:"ul"},"how do modules determine a minor dependency module API revision requirement"),(0,i.kt)("li",{parentName:"ul"},"how do modules appropriately test compatibility with different dependency versions"),(0,i.kt)("li",{parentName:"ul"},"how to register and resolve interface implementations"),(0,i.kt)("li",{parentName:"ul"},"how do modules register their protobuf file descriptors depending on the approach they take to generated code (the\nAPI module approach may still be viable as a supported strategy and would need pinned file descriptors)")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10162"},"https://github.com/cosmos/cosmos-sdk/discussions/10162")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10582"},"https://github.com/cosmos/cosmos-sdk/discussions/10582")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10368"},"https://github.com/cosmos/cosmos-sdk/discussions/10368")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/pull/11340"},"https://github.com/cosmos/cosmos-sdk/pull/11340")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/issues/11899"},"https://github.com/cosmos/cosmos-sdk/issues/11899")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/v0.50/architecture/adr-020-protobuf-transaction-encoding"},"ADR 020")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/v0.50/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"))))}c.isMDXComponent=!0}}]);