"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[7058],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,k=u["".concat(l,".").concat(m)]||u[m]||p[m]||s;return n?o.createElement(k,i(i({ref:t},d),{},{components:n})):o.createElement(k,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,i[1]=r;for(var c=2;c<s;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},58314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=n(87462),a=(n(67294),n(3905));const s={},i="Collections",r={unversionedId:"packages/collections",id:"packages/collections",title:"Collections",description:"Collections is a library meant to simplify the experience with respect to module state handling.",source:"@site/docs/packages/02-collections.md",sourceDirName:"packages",slug:"/packages/collections",permalink:"/main/packages/collections",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Depinject",permalink:"/main/packages/depinject"},next:{title:"ORM",permalink:"/main/packages/orm"}},l={},c=[{value:"Installation",id:"installation",level:2},{value:"Core types",id:"core-types",level:2},{value:"Preliminary components",id:"preliminary-components",level:2},{value:"SchemaBuilder",id:"schemabuilder",level:3},{value:"Prefix",id:"prefix",level:3},{value:"Rules",id:"rules",level:4},{value:"Human-Readable Name",id:"human-readable-name",level:3},{value:"Rules",id:"rules-1",level:4},{value:"Key and Value Codecs",id:"key-and-value-codecs",level:2},{value:"Map",id:"map",level:2},{value:"Use case",id:"use-case",level:3},{value:"Example",id:"example",level:3},{value:"Set method",id:"set-method",level:4},{value:"Has method",id:"has-method",level:4},{value:"Get method",id:"get-method",level:4},{value:"Remove method",id:"remove-method",level:4},{value:"Iteration",id:"iteration",level:4},{value:"KeySet",id:"keyset",level:2},{value:"Implementation curiosity",id:"implementation-curiosity",level:4},{value:"Example",id:"example-1",level:3},{value:"Has method",id:"has-method-1",level:4},{value:"Set method",id:"set-method-1",level:4},{value:"Remove method",id:"remove-method-1",level:4},{value:"Item",id:"item",level:2},{value:"implementation curiosity",id:"implementation-curiosity-1",level:4},{value:"Example",id:"example-2",level:3},{value:"Iteration",id:"iteration-1",level:2},{value:"Example",id:"example-3",level:3},{value:"GetAllAccounts",id:"getallaccounts",level:4},{value:"IterateAccountsBetween",id:"iterateaccountsbetween",level:4},{value:"IterateAccounts",id:"iterateaccounts",level:4},{value:"Composite keys",id:"composite-keys",level:2},{value:"Example",id:"example-4",level:3},{value:"Instantiation of a composite key collection",id:"instantiation-of-a-composite-key-collection",level:2},{value:"The Map Key definition",id:"the-map-key-definition",level:4},{value:"The Key Codec instantiation",id:"the-key-codec-instantiation",level:4},{value:"Working with composite key collections",id:"working-with-composite-key-collections",level:3},{value:"SetBalance",id:"setbalance",level:4},{value:"GetBalance",id:"getbalance",level:4},{value:"GetAllAddressBalances",id:"getalladdressbalances",level:4},{value:"GetAllAddressesBalancesBetween",id:"getalladdressesbalancesbetween",level:4},{value:"IndexedMap",id:"indexedmap",level:2},{value:"Example",id:"example-5",level:3},{value:"Instantiating a <code>indexes.Unique</code>",id:"instantiating-a-indexesunique",level:4},{value:"Working with IndexedMaps",id:"working-with-indexedmaps",level:3},{value:"Collections with interfaces as values",id:"collections-with-interfaces-as-values",level:2},{value:"Instantiating Collections with interface values",id:"instantiating-collections-with-interface-values",level:3},{value:"Triple key",id:"triple-key",level:2},{value:"Advanced Usages",id:"advanced-usages",level:2},{value:"Alternative Value Codec",id:"alternative-value-codec",level:3}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"collections"},"Collections"),(0,a.kt)("p",null,"Collections is a library meant to simplify the experience with respect to module state handling."),(0,a.kt)("p",null,"Cosmos SDK modules handle their state using the ",(0,a.kt)("inlineCode",{parentName:"p"},"KVStore")," interface. The problem with working with\n",(0,a.kt)("inlineCode",{parentName:"p"},"KVStore")," is that it forces you to think of state as a bytes KV pairings when in reality the majority of\nstate comes from complex concrete golang objects (strings, ints, structs, etc.)."),(0,a.kt)("p",null,"Collections allows you to work with state as if they were normal golang objects and removes the need\nfor you to think of your state as raw bytes in your code."),(0,a.kt)("p",null,"It also allows you to migrate your existing state without causing any state breakage that forces you into\ntedious and complex chain state migrations."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"To install collections in your cosmos-sdk chain project, run the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"go get cosmossdk.io/collections\n")),(0,a.kt)("h2",{id:"core-types"},"Core types"),(0,a.kt)("p",null,"Collections offers 5 different APIs to work with state, which will be explored in the next sections, these APIs are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Map"),": to work with typed arbitrary KV pairings."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"KeySet"),": to work with just typed keys"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Item"),": to work with just one typed value"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Sequence"),": which is a monotonically increasing number."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"IndexedMap"),": which combines ",(0,a.kt)("inlineCode",{parentName:"li"},"Map")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"KeySet")," to provide a ",(0,a.kt)("inlineCode",{parentName:"li"},"Map")," with indexing capabilities.")),(0,a.kt)("h2",{id:"preliminary-components"},"Preliminary components"),(0,a.kt)("p",null,"Before exploring the different collections types and their capability it is necessary to introduce\nthe three components that every collection shares. In fact when instantiating a collection type by doing, for example,\n",(0,a.kt)("inlineCode",{parentName:"p"},"collections.NewMap/collections.NewItem/...")," you will find yourself having to pass them some common arguments."),(0,a.kt)("p",null,"For example, in code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n)\n\nvar AllowListPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema    collections.Schema\n    AllowList collections.KeySet[string]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n\n    return Keeper{\n        AllowList: collections.NewKeySet(sb, AllowListPrefix, "allow_list", collections.StringKey),\n    }\n}\n\n')),(0,a.kt)("p",null,"Let's analyse the shared arguments, what they do, and why we need them."),(0,a.kt)("h3",{id:"schemabuilder"},"SchemaBuilder"),(0,a.kt)("p",null,"The first argument passed is the ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder")," is a structure that keeps track of all the state of a module, it is not required by the collections\nto deal with state but it offers a dynamic and reflective way for clients to explore a module's state."),(0,a.kt)("p",null,"We instantiate a ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder")," by passing it a function that given the modules store key returns the module's specific store."),(0,a.kt)("p",null,"We then need to pass the schema builder to every collection type we instantiate in our keeper, in our case the ",(0,a.kt)("inlineCode",{parentName:"p"},"AllowList"),"."),(0,a.kt)("h3",{id:"prefix"},"Prefix"),(0,a.kt)("p",null,"The second argument passed to our ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," is a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Prefix"),", a prefix represents a partition of the module's ",(0,a.kt)("inlineCode",{parentName:"p"},"KVStore"),"\nwhere all the state of a specific collection will be saved. "),(0,a.kt)("p",null,"Since a module can have multiple collections, the following is expected:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"module params will become a ",(0,a.kt)("inlineCode",{parentName:"li"},"collections.Item")),(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("inlineCode",{parentName:"li"},"AllowList")," is a ",(0,a.kt)("inlineCode",{parentName:"li"},"collections.KeySet"))),(0,a.kt)("p",null,"We don't want a collection to write over the state of the other collection so we pass it a prefix, which defines a storage\npartition owned by the collection."),(0,a.kt)("p",null,"If you already built modules, the prefix translates to the items you were creating in your ",(0,a.kt)("inlineCode",{parentName:"p"},"types/keys.go")," file, example: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/main/x/feegrant/key.go#L27"},"https://github.com/cosmos/cosmos-sdk/blob/main/x/feegrant/key.go#L27")),(0,a.kt)("p",null,"your old:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    // FeeAllowanceKeyPrefix is the set of the kvstore for fee allowance data\n    // - 0x00<allowance_key_bytes>: allowance\n    FeeAllowanceKeyPrefix = []byte{0x00}\n\n    // FeeAllowanceQueueKeyPrefix is the set of the kvstore for fee allowance keys data\n    // - 0x01<allowance_prefix_queue_key_bytes>: <empty value>\n    FeeAllowanceQueueKeyPrefix = []byte{0x01}\n)\n")),(0,a.kt)("p",null,"becomes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    // FeeAllowanceKeyPrefix is the set of the kvstore for fee allowance data\n    // - 0x00<allowance_key_bytes>: allowance\n    FeeAllowanceKeyPrefix = collections.NewPrefix(0)\n\n    // FeeAllowanceQueueKeyPrefix is the set of the kvstore for fee allowance keys data\n    // - 0x01<allowance_prefix_queue_key_bytes>: <empty value>\n    FeeAllowanceQueueKeyPrefix = collections.NewPrefix(1)\n)\n")),(0,a.kt)("h4",{id:"rules"},"Rules"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"collections.NewPrefix")," accepts either ",(0,a.kt)("inlineCode",{parentName:"p"},"uint8"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"[]bytes")," it's good practice to use an always increasing ",(0,a.kt)("inlineCode",{parentName:"p"},"uint8"),"for disk space efficiency."),(0,a.kt)("p",null,"A collection ",(0,a.kt)("strong",{parentName:"p"},"MUST NOT")," share the same prefix as another collection in the same module, and a collection prefix ",(0,a.kt)("strong",{parentName:"p"},"MUST NEVER")," start with the same prefix as another, examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'prefix1 := collections.NewPrefix("prefix")\nprefix2 := collections.NewPrefix("prefix") // THIS IS BAD!\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'prefix1 := collections.NewPrefix("a")\nprefix2 := collections.NewPrefix("aa") // prefix2 starts with the same as prefix1: BAD!!!\n')),(0,a.kt)("h3",{id:"human-readable-name"},"Human-Readable Name"),(0,a.kt)("p",null,"The third parameter we pass to a collection is a string, which is a human-readable name.\nIt is needed to make the role of a collection understandable by clients who have no clue about\nwhat a module is storing in state."),(0,a.kt)("h4",{id:"rules-1"},"Rules"),(0,a.kt)("p",null,"Each collection in a module ",(0,a.kt)("strong",{parentName:"p"},"MUST")," have a unique humanised name."),(0,a.kt)("h2",{id:"key-and-value-codecs"},"Key and Value Codecs"),(0,a.kt)("p",null,"A collection is generic over the type you can use as keys or values.\nThis makes collections dumb, but also means that hypothetically we can store everything\nthat can be a go type into a collection. We are not bounded to any type of encoding (be it proto, json or whatever)"),(0,a.kt)("p",null,"So a collection needs to be given a way to understand how to convert your keys and values to bytes.\nThis is achieved through ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ValueCodec"),", which are arguments that you pass to your\ncollections when you're instantiating them using the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.NewMap/collections.NewItem/..."),"\ninstantiation functions."),(0,a.kt)("p",null,"NOTE: Generally speaking you will never be required to implement your own ",(0,a.kt)("inlineCode",{parentName:"p"},"Key/ValueCodec")," as\nthe SDK and collections libraries already come with default, safe and fast implementation of those.\nYou might need to implement them only if you're migrating to collections and there are state layout incompatibilities."),(0,a.kt)("p",null,"Let's explore an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n)\n\nvar IDsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema    collections.Schema\n    IDs   collections.Map[string, uint64]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n\n    return Keeper{\n        IDs: collections.NewMap(sb, IDsPrefix, "ids", collections.StringKey, collections.Uint64Value),\n    }\n}\n')),(0,a.kt)("p",null,"We're now instantiating a map where the key is string and the value is ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64"),".\nWe already know the first three arguments of the ",(0,a.kt)("inlineCode",{parentName:"p"},"NewMap")," function."),(0,a.kt)("p",null,"The fourth parameter is our ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec"),", we know that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," has ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," as key so we pass it a ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec")," that handles strings as keys."),(0,a.kt)("p",null,"The fifth parameter is our ",(0,a.kt)("inlineCode",{parentName:"p"},"ValueCodec"),", we know that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Map")," as a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64")," as value so we pass it a ",(0,a.kt)("inlineCode",{parentName:"p"},"ValueCodec")," that handles uint64."),(0,a.kt)("p",null,"Collections already comes with all the required implementations for golang primitive types."),(0,a.kt)("p",null,"Let's make another example, this falls closer to what we build using cosmos SDK, let's say we want\nto create a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," that maps account addresses to their base account. So we want to map an ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," to an ",(0,a.kt)("inlineCode",{parentName:"p"},"auth.BaseAccount")," (which is a proto):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema    collections.Schema\n    Accounts   collections.Map[sdk.AccAddress, authtypes.BaseAccount]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewMap(sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollValue[authtypes.BaseAccount](cdc)),\n    }\n}\n')),(0,a.kt)("p",null,"As we can see here since our ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," maps ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"authtypes.BaseAccount"),",\nwe use the ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddressKey")," which is the ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec")," implementation for ",(0,a.kt)("inlineCode",{parentName:"p"},"AccAddress")," and we use ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValue")," to\nencode our proto type ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseAccount"),"."),(0,a.kt)("p",null,"Generally speaking you will always find the respective key and value codecs for types in the ",(0,a.kt)("inlineCode",{parentName:"p"},"go.mod")," path you're using\nto import that type. If you want to encode proto values refer to the codec ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValue")," function, which allows you\nto encode any type implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"proto.Message")," interface."),(0,a.kt)("h2",{id:"map"},"Map"),(0,a.kt)("p",null,"We analyse the first and most important collection type, the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map"),".\nThis is the type that everything else builds on top of."),(0,a.kt)("h3",{id:"use-case"},"Use case"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," is used to map arbitrary keys with arbitrary values."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"It's easier to explain a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," capabilities through an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "fmt"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema    collections.Schema\n    Accounts   collections.Map[sdk.AccAddress, authtypes.BaseAccount]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewMap(sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollValue[authtypes.BaseAccount](cdc)),\n    }\n}\n\nfunc (k Keeper) CreateAccount(ctx sdk.Context, addr sdk.AccAddress, account authtypes.BaseAccount) error {\n    has, err := k.Accounts.Has(ctx, addr)\n    if err != nil {\n        return err\n    }\n    if has {\n        return fmt.Errorf("account already exists: %s", addr)\n    }\n    \n    err = k.Accounts.Set(ctx, addr, account)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc (k Keeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) (authtypes.BaseAccount, error) {\n    acc, err := k.Accounts.Get(ctx, addr)\n    if err != nil {\n        return authtypes.BaseAccount{}, err\n    }\n    \n    return acc, nil\n}\n\nfunc (k Keeper) RemoveAccount(ctx sdk.Context, addr sdk.AccAddress) error {\n    err := k.Accounts.Remove(ctx, addr)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n')),(0,a.kt)("h4",{id:"set-method"},"Set method"),(0,a.kt)("p",null,"Set maps with the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"AccAddress")," (the key) to the ",(0,a.kt)("inlineCode",{parentName:"p"},"auth.BaseAccount")," (the value)."),(0,a.kt)("p",null,"Under the hood the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," will convert the key and value to bytes using the ",(0,a.kt)("a",{parentName:"p",href:"README.md#key-and-value-codecs"},"key and value codec"),".\nIt will prepend to our bytes key the ",(0,a.kt)("a",{parentName:"p",href:"README.md#prefix"},"prefix")," and store it in the KVStore of the module."),(0,a.kt)("h4",{id:"has-method"},"Has method"),(0,a.kt)("p",null,"The has method reports if the provided key exists in the store."),(0,a.kt)("h4",{id:"get-method"},"Get method"),(0,a.kt)("p",null,"The get method accepts the ",(0,a.kt)("inlineCode",{parentName:"p"},"AccAddress")," and returns the associated ",(0,a.kt)("inlineCode",{parentName:"p"},"auth.BaseAccount")," if it exists, otherwise it errors."),(0,a.kt)("h4",{id:"remove-method"},"Remove method"),(0,a.kt)("p",null,"The remove method accepts the ",(0,a.kt)("inlineCode",{parentName:"p"},"AccAddress")," and removes it from the store. It won't report errors\nif it does not exist, to check for existence before removal use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Has")," method."),(0,a.kt)("h4",{id:"iteration"},"Iteration"),(0,a.kt)("p",null,"Iteration has a separate section."),(0,a.kt)("h2",{id:"keyset"},"KeySet"),(0,a.kt)("p",null,"The second type of collection is ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.KeySet"),", as the word suggests it maintains\nonly a set of keys without values."),(0,a.kt)("h4",{id:"implementation-curiosity"},"Implementation curiosity"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.KeySet")," is just a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," with a ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," but no value.\nThe value internally is always the same and is represented as an empty byte slice ",(0,a.kt)("inlineCode",{parentName:"p"},"[]byte{}"),"."),(0,a.kt)("h3",{id:"example-1"},"Example"),(0,a.kt)("p",null,"As always we explore the collection type through an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "fmt"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n)\n\nvar ValidatorsSetPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema        collections.Schema\n    ValidatorsSet collections.KeySet[sdk.ValAddress]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        ValidatorsSet: collections.NewKeySet(sb, ValidatorsSetPrefix, "validators_set", sdk.ValAddressKey),\n    }\n}\n\nfunc (k Keeper) AddValidator(ctx sdk.Context, validator sdk.ValAddress) error {\n    has, err := k.ValidatorsSet.Has(ctx, validator)\n    if err != nil {\n        return err\n    }\n    if has {\n        return fmt.Errorf("validator already in set: %s", validator)\n    }\n    \n    err = k.ValidatorsSet.Set(ctx, validator)\n    if err != nil {\n        return err\n    }\n    \n    return nil\n}\n\nfunc (k Keeper) RemoveValidator(ctx sdk.Context, validator sdk.ValAddress) error {\n    err := k.ValidatorsSet.Remove(ctx, validator)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n')),(0,a.kt)("p",null,"The first difference we notice is that ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," needs use to specify only one type parameter: the key (",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.ValAddress")," in this case).\nThe second difference we notice is that ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," in its ",(0,a.kt)("inlineCode",{parentName:"p"},"NewKeySet")," function does not require\nus to specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"ValueCodec")," but only a ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec"),". This is because a ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," only saves keys and not values."),(0,a.kt)("p",null,"Let's explore the methods."),(0,a.kt)("h4",{id:"has-method-1"},"Has method"),(0,a.kt)("p",null,"Has allows us to understand if a key is present in the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.KeySet")," or not, functions in the same way as ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map.Has\n")),(0,a.kt)("h4",{id:"set-method-1"},"Set method"),(0,a.kt)("p",null,"Set inserts the provided key in the ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet"),"."),(0,a.kt)("h4",{id:"remove-method-1"},"Remove method"),(0,a.kt)("p",null,"Remove removes the provided key from the ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet"),", it does not error if the key does not exist,\nif existence check before removal is required it needs to be coupled with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Has")," method."),(0,a.kt)("h2",{id:"item"},"Item"),(0,a.kt)("p",null,"The third type of collection is the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Item"),".\nIt stores only one single item, it's useful for example for parameters, there's only one instance\nof parameters in state always."),(0,a.kt)("h4",{id:"implementation-curiosity-1"},"implementation curiosity"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Item")," is just a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," with no key but just a value.\nThe key is the prefix of the collection!"),(0,a.kt)("h3",{id:"example-2"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"\n)\n\nvar ParamsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema        collections.Schema\n    Params collections.Item[stakingtypes.Params]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Params: collections.NewItem(sb, ParamsPrefix, "params", codec.CollValue[stakingtypes.Params](cdc)),\n    }\n}\n\nfunc (k Keeper) UpdateParams(ctx sdk.Context, params stakingtypes.Params) error {\n    err := k.Params.Set(ctx, params)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc (k Keeper) GetParams(ctx sdk.Context) (stakingtypes.Params, error) {\n    return k.Params.Get(ctx)\n}\n')),(0,a.kt)("p",null,"The first key difference we notice is that we specify only one type parameter, which is the value we're storing.\nThe second key difference is that we don't specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec"),", since we store only one item we already know the key\nand the fact that it is constant."),(0,a.kt)("h2",{id:"iteration-1"},"Iteration"),(0,a.kt)("p",null,"One of the key features of the ",(0,a.kt)("inlineCode",{parentName:"p"},"KVStore")," is iterating over keys."),(0,a.kt)("p",null,"Collections which deal with keys (so ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexedMap"),") allow you to iterate\nover keys in a safe and typed way. They all share the same API, the only difference being\nthat ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," returns a different type of ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," because ",(0,a.kt)("inlineCode",{parentName:"p"},"KeySet")," only deals with keys."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Every collection shares the same ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," semantics.")),(0,a.kt)("p",null,"Let's have a look at the ",(0,a.kt)("inlineCode",{parentName:"p"},"Map.Iterate")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (m Map[K, V]) Iterate(ctx context.Context, ranger Ranger[K]) (Iterator[K, V], error) \n")),(0,a.kt)("p",null,"It accepts a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Ranger[K]"),", which is an API that instructs map on how to iterate over keys.\nAs always we don't need to implement anything here as ",(0,a.kt)("inlineCode",{parentName:"p"},"collections")," already provides some generic ",(0,a.kt)("inlineCode",{parentName:"p"},"Ranger")," implementers\nthat expose all you need to work with ranges."),(0,a.kt)("h3",{id:"example-3"},"Example"),(0,a.kt)("p",null,"We have a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," that maps accounts using ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64")," IDs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Accounts collections.Map[uint64, authtypes.BaseAccount]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewMap(sb, AccountsPrefix, "accounts", collections.Uint64Key, codec.CollValue[authtypes.BaseAccount](cdc)),\n    }\n}\n\nfunc (k Keeper) GetAllAccounts(ctx sdk.Context) ([]authtypes.BaseAccount, error) {\n    // passing a nil Ranger equals to: iterate over every possible key\n    iter, err := k.Accounts.Iterate(ctx, nil)\n    if err != nil {\n        return nil, err\n    }\n    accounts, err := iter.Values()\n    if err != nil {\n        return nil, err\n    }\n\n    return accounts, err\n}\n\nfunc (k Keeper) IterateAccountsBetween(ctx sdk.Context, start, end uint64) ([]authtypes.BaseAccount, error) {\n    // The collections.Range API offers a lot of capabilities\n    // like defining where the iteration starts or ends.\n    rng := new(collections.Range[uint64]).\n        StartInclusive(start).\n        EndExclusive(end).\n        Descending()\n\n    iter, err := k.Accounts.Iterate(ctx, rng)\n    if err != nil {\n        return nil, err\n    }\n    accounts, err := iter.Values()\n    if err != nil {\n        return nil, err\n    }\n\n    return accounts, nil\n}\n\nfunc (k Keeper) IterateAccounts(ctx sdk.Context, do func(id uint64, acc authtypes.BaseAccount) (stop bool)) error {\n    iter, err := k.Accounts.Iterate(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer iter.Close()\n\n    for ; iter.Valid(); iter.Next() {\n        kv, err := iter.KeyValue()\n        if err != nil {\n            return err\n        }\n\n        if do(kv.Key, kv.Value) {\n            break\n        }\n    }\n    return nil\n}\n')),(0,a.kt)("p",null,"Let's analyse each method in the example and how it makes use of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterate")," and the returned ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," API."),(0,a.kt)("h4",{id:"getallaccounts"},"GetAllAccounts"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"GetAllAccounts")," we pass to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterate")," a nil ",(0,a.kt)("inlineCode",{parentName:"p"},"Ranger"),". This means that the returned ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," will include\nall the existing keys within the collection."),(0,a.kt)("p",null,"Then we use some the ",(0,a.kt)("inlineCode",{parentName:"p"},"Values")," method from the returned ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," API to collect all the values into a slice."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," offers other methods such as ",(0,a.kt)("inlineCode",{parentName:"p"},"Keys()")," to collect only the keys and not the values and ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyValues")," to collect\nall the keys and values."),(0,a.kt)("h4",{id:"iterateaccountsbetween"},"IterateAccountsBetween"),(0,a.kt)("p",null,"Here we make use of the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Range")," helper to specialise our range.\nWe make it start in a point through ",(0,a.kt)("inlineCode",{parentName:"p"},"StartInclusive")," and end in the other with ",(0,a.kt)("inlineCode",{parentName:"p"},"EndExclusive"),", then\nwe instruct it to report us results in reverse order through ",(0,a.kt)("inlineCode",{parentName:"p"},"Descending")),(0,a.kt)("p",null,"Then we pass the range instruction to ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterate")," and get an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),", which will contain only the results\nwe specified in the range."),(0,a.kt)("p",null,"Then we use again th ",(0,a.kt)("inlineCode",{parentName:"p"},"Values")," method of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," to collect all the results."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"collections.Range")," also offers a ",(0,a.kt)("inlineCode",{parentName:"p"},"Prefix")," API which is not appliable to all keys types,\nfor example uint64 cannot be prefix because it is of constant size, but a ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," key\ncan be prefixed."),(0,a.kt)("h4",{id:"iterateaccounts"},"IterateAccounts"),(0,a.kt)("p",null,"Here we showcase how to lazily collect values from an Iterator. "),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"Keys/Values/KeyValues")," fully consume and close the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),", here we need to explicitly do a ",(0,a.kt)("inlineCode",{parentName:"p"},"defer iterator.Close()")," call.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," also exposes a ",(0,a.kt)("inlineCode",{parentName:"p"},"Value")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Key")," method to collect only the current value or key, if collecting both is not needed."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"For this ",(0,a.kt)("inlineCode",{parentName:"p"},"callback")," pattern, collections expose a ",(0,a.kt)("inlineCode",{parentName:"p"},"Walk")," API.")),(0,a.kt)("h2",{id:"composite-keys"},"Composite keys"),(0,a.kt)("p",null,"So far we've worked only with simple keys, like ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64"),", the account address, etc.\nThere are some more complex cases in, which we need to deal with composite keys."),(0,a.kt)("p",null,"A key is composite when it is composed of multiple keys, for example bank balances as stored as the composite key\n",(0,a.kt)("inlineCode",{parentName:"p"},"(AccAddress, string)")," where the first part is the address holding the coins and the second part is the denom."),(0,a.kt)("p",null,"Example, let's say address ",(0,a.kt)("inlineCode",{parentName:"p"},"BOB")," holds ",(0,a.kt)("inlineCode",{parentName:"p"},"10atom,15osmo"),", this is how it is stored in state:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"(bob, atom) => 10\n(bob, osmos) => 15\n")),(0,a.kt)("p",null,"Now this allows to efficiently get a specific denom balance of an address, by simply ",(0,a.kt)("inlineCode",{parentName:"p"},"getting")," ",(0,a.kt)("inlineCode",{parentName:"p"},"(address, denom)"),", or getting all the balances\nof an address by prefixing over ",(0,a.kt)("inlineCode",{parentName:"p"},"(address)"),"."),(0,a.kt)("p",null,"Let's see now how we can work with composite keys using collections."),(0,a.kt)("h3",{id:"example-4"},"Example"),(0,a.kt)("p",null,"In our example we will show-case how we can use collections when we are dealing with balances, similar to bank,\na balance is a mapping between ",(0,a.kt)("inlineCode",{parentName:"p"},"(address, denom) => math.Int")," the composite key in our case is ",(0,a.kt)("inlineCode",{parentName:"p"},"(address, denom)"),"."),(0,a.kt)("h2",{id:"instantiation-of-a-composite-key-collection"},"Instantiation of a composite key collection"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package collections\n\nimport (\n    "cosmossdk.io/collections"\n    "cosmossdk.io/math"\n    storetypes "cosmossdk.io/store/types"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n)\n\n\nvar BalancesPrefix = collections.NewPrefix(1)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Balances collections.Map[collections.Pair[sdk.AccAddress, string], math.Int]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Balances: collections.NewMap(\n            sb, BalancesPrefix, "balances",\n            collections.PairKeyCodec(sdk.AccAddressKey, collections.StringKey),\n            math.IntValue,\n        ),\n    }\n}\n')),(0,a.kt)("h4",{id:"the-map-key-definition"},"The Map Key definition"),(0,a.kt)("p",null,"First of all we can see that in order to define a composite key of two elements we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair")," type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"collections.Map[collections.Pair[sdk.AccAddress, string], math.Int]\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair")," defines a key composed of two other keys, in our case the first part is ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress"),", the second\npart is ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,a.kt)("h4",{id:"the-key-codec-instantiation"},"The Key Codec instantiation"),(0,a.kt)("p",null,"The arguments to instantiate are always the same, the only thing that changes is how we instantiate\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec"),", since this key is composed of two keys we use ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.PairKeyCodec"),", which generates\na ",(0,a.kt)("inlineCode",{parentName:"p"},"KeyCodec")," composed of two key codecs. The first one will encode the first part of the key, the second one will\nencode the second part of the key."),(0,a.kt)("h3",{id:"working-with-composite-key-collections"},"Working with composite key collections"),(0,a.kt)("p",null,"Let's expand on the example we used before:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var BalancesPrefix = collections.NewPrefix(1)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Balances collections.Map[collections.Pair[sdk.AccAddress, string], math.Int]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Balances: collections.NewMap(\n            sb, BalancesPrefix, "balances",\n            collections.PairKeyCodec(sdk.AccAddressKey, collections.StringKey),\n            math.IntValue,\n        ),\n    }\n}\n\nfunc (k Keeper) SetBalance(ctx sdk.Context, address sdk.AccAddress, denom string, amount math.Int) error {\n    key := collections.Join(address, denom)\n    return k.Balances.Set(ctx, key, amount)\n}\n\nfunc (k Keeper) GetBalance(ctx sdk.Context, address sdk.AccAddress, denom string) (math.Int, error) {\n    return k.Balances.Get(ctx, collections.Join(address, denom))\n}\n\nfunc (k Keeper) GetAllAddressBalances(ctx sdk.Context, address sdk.AccAddress) (sdk.Coins, error) {\n    balances := sdk.NewCoins()\n\n    rng := collections.NewPrefixedPairRange[sdk.AccAddress, string](address)\n\n    iter, err := k.Balances.Iterate(ctx, rng)\n    if err != nil {\n        return nil, err\n    }\n\n    kvs, err := iter.KeyValues()\n    if err != nil {\n        return nil, err\n    }\n\n    for _, kv := range kvs {\n        balances = balances.Add(sdk.NewCoin(kv.Key.K2(), kv.Value))\n    }\n    return balances, nil\n}\n\nfunc (k Keeper) GetAllAddressBalancesBetween(ctx sdk.Context, address sdk.AccAddress, startDenom, endDenom string) (sdk.Coins, error) {\n    rng := collections.NewPrefixedPairRange[sdk.AccAddress, string](address).\n        StartInclusive(startDenom).\n        EndInclusive(endDenom)\n\n    iter, err := k.Balances.Iterate(ctx, rng)\n    if err != nil {\n        return nil, err\n    }\n    ...\n}\n')),(0,a.kt)("h4",{id:"setbalance"},"SetBalance"),(0,a.kt)("p",null,"As we can see here we're setting the balance of an address for a specific denom.\nWe use the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Join")," function to generate the composite key.\n",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Join")," returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair")," (which is the key of our ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map"),")"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair")," contains the two keys we have joined, it also exposes two methods: ",(0,a.kt)("inlineCode",{parentName:"p"},"K1")," to fetch the 1st part of the\nkey and ",(0,a.kt)("inlineCode",{parentName:"p"},"K2")," to fetch the second part."),(0,a.kt)("p",null,"As always, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map.Set")," method to map the composite key to our value (",(0,a.kt)("inlineCode",{parentName:"p"},"math.Int"),"in this case)"),(0,a.kt)("h4",{id:"getbalance"},"GetBalance"),(0,a.kt)("p",null,"To get a value in composite key collection, we simply use ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Join")," to compose the key."),(0,a.kt)("h4",{id:"getalladdressbalances"},"GetAllAddressBalances"),(0,a.kt)("p",null,"We use ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.PrefixedPairRange")," to iterate over all the keys starting with the provided address.\nConcretely the iteration will report all the balances belonging to the provided address."),(0,a.kt)("p",null,"The first part is that we instantiate a ",(0,a.kt)("inlineCode",{parentName:"p"},"PrefixedPairRange"),", which is a ",(0,a.kt)("inlineCode",{parentName:"p"},"Ranger")," implementer aimed to help\nin ",(0,a.kt)("inlineCode",{parentName:"p"},"Pair")," keys iterations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"    rng := collections.NewPrefixedPairRange[sdk.AccAddress, string](address)\n")),(0,a.kt)("p",null,"As we can see here we're passing the type parameters of the ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair")," because golang type inference\nwith respect to generics is not as permissive as other languages, so we need to explitly say what are the types of the pair key."),(0,a.kt)("h4",{id:"getalladdressesbalancesbetween"},"GetAllAddressesBalancesBetween"),(0,a.kt)("p",null,"This showcases how we can further specialise our range to limit the results further, by specifying\nthe range between the second part of the key (in our case the denoms, which are strings)."),(0,a.kt)("h2",{id:"indexedmap"},"IndexedMap"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"collections.IndexedMap")," is a collection that uses under the hood a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map"),", and has a struct, which contains the indexes that we need to define."),(0,a.kt)("h3",{id:"example-5"},"Example"),(0,a.kt)("p",null,"Let's say we have an ",(0,a.kt)("inlineCode",{parentName:"p"},"auth.BaseAccount")," struct which looks like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'type BaseAccount struct {\n    AccountNumber uint64     `protobuf:"varint,3,opt,name=account_number,json=accountNumber,proto3" json:"account_number,omitempty"`\n    Sequence      uint64     `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`\n}\n')),(0,a.kt)("p",null,"First of all, when we save our accounts in state we map them using a primary key ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress"),".\nIf it were to be a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map")," it would be ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map[sdk.AccAddres, authtypes.BaseAccount]"),"."),(0,a.kt)("p",null,"Then we also want to be able to get an account not only by its ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress"),", but also by its ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber"),"."),(0,a.kt)("p",null,"So we can say we want to create an ",(0,a.kt)("inlineCode",{parentName:"p"},"Index")," that maps our ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseAccount")," to its ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber"),"."),(0,a.kt)("p",null,"We also know that this ",(0,a.kt)("inlineCode",{parentName:"p"},"Index")," is unique. Unique means that there can only be one ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseAccount")," that maps to a specific\n",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber"),"."),(0,a.kt)("p",null,"First of all, we start by defining the object that contains our index:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var AccountsNumberIndexPrefix = collections.NewPrefix(1)\n\ntype AccountsIndexes struct {\n    Number *indexes.Unique[uint64, sdk.AccAddress, authtypes.BaseAccount]\n}\n\nfunc (a AccountsIndexes) IndexesList() []collections.Index[sdk.AccAddress, authtypes.BaseAccount] {\n    return []collections.Index[sdk.AccAddress, authtypes.BaseAccount]{a.Number}\n}\n\nfunc NewAccountIndexes(sb *collections.SchemaBuilder) AccountsIndexes {\n    return AccountsIndexes{\n        Number: indexes.NewUnique(\n            sb, AccountsNumberIndexPrefix, "accounts_by_number",\n            collections.Uint64Key, sdk.AccAddressKey,\n            func(_ sdk.AccAddress, v authtypes.BaseAccount) (uint64, error) {\n                return v.AccountNumber, nil\n            },\n        ),\n    }\n}\n')),(0,a.kt)("p",null,"We create an ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountIndexes")," struct which contains a field: ",(0,a.kt)("inlineCode",{parentName:"p"},"Number"),". This field represents our ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber")," index.\n",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber")," is a field of ",(0,a.kt)("inlineCode",{parentName:"p"},"authtypes.BaseAccount")," and it's a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64"),"."),(0,a.kt)("p",null,"Then we can see in our ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountIndexes")," struct the ",(0,a.kt)("inlineCode",{parentName:"p"},"Number")," field is defined as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"*indexes.Unique[uint64, sdk.AccAddress, authtypes.BaseAccount]\n")),(0,a.kt)("p",null,"Where the first type parameter is ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64"),", which is the field type of our index.\nThe second type parameter is the primary key ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress"),"\nAnd the third type parameter is the actual object we're storing ",(0,a.kt)("inlineCode",{parentName:"p"},"authtypes.BaseAccount"),"."),(0,a.kt)("p",null,"Then we implement a function called ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexesList")," on our ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountIndexes")," struct, this will be used\nby the ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexedMap")," to keep the underlying map in sync with the indexes, in our case ",(0,a.kt)("inlineCode",{parentName:"p"},"Number"),".\nThis function just needs to return the slice of indexes contained in the struct."),(0,a.kt)("p",null,"Then we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"NewAccountIndexes")," function that instantiates and returns the ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountsIndexes")," struct."),(0,a.kt)("p",null,"The function takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder"),". Then we instantiate our ",(0,a.kt)("inlineCode",{parentName:"p"},"indexes.Unique"),", let's analyse the arguments we pass to\n",(0,a.kt)("inlineCode",{parentName:"p"},"indexes.NewUnique"),"."),(0,a.kt)("h4",{id:"instantiating-a-indexesunique"},"Instantiating a ",(0,a.kt)("inlineCode",{parentName:"h4"},"indexes.Unique")),(0,a.kt)("p",null,"The first three arguments, we already know them, they are: ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Prefix")," which is our index prefix (the partition\nwhere index keys relationship for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Number")," index will be maintained), and the human name for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Number")," index."),(0,a.kt)("p",null,"The second argument is a ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Uint64Key")," which is a key codec to deal with ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64")," keys, we pass that because\nthe key we're trying to index is a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint64")," key (the account number), and then we pass as fifth argument the primary key codec,\nwhich in our case is ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," (remember: we're mapping ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," => ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseAccount"),")."),(0,a.kt)("p",null,"Then as last parameter we pass a function that: given the ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseAccount")," returns its ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountNumber"),"."),(0,a.kt)("p",null,"After this we can proceed instantiating our ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexedMap"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Accounts *collections.IndexedMap[sdk.AccAddress, authtypes.BaseAccount, AccountsIndexes]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewIndexedMap(\n            sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollValue[authtypes.BaseAccount](cdc),\n            NewAccountIndexes(sb),\n        ),\n    }\n}\n')),(0,a.kt)("p",null,"As we can see here what we do, for now, is the same thing as we did for ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Map"),".\nWe pass it the ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaBuilder"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"Prefix")," where we plan to store the mapping between ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"authtypes.BaseAccount"),",\nthe human name and the respective ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," key codec and ",(0,a.kt)("inlineCode",{parentName:"p"},"authtypes.BaseAccount")," value codec."),(0,a.kt)("p",null,"Then we pass the instantiation of our ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountIndexes")," through ",(0,a.kt)("inlineCode",{parentName:"p"},"NewAccountIndexes"),"."),(0,a.kt)("p",null,"Full example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package docs\n\nimport (\n    "cosmossdk.io/collections"\n    "cosmossdk.io/collections/indexes"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsNumberIndexPrefix = collections.NewPrefix(1)\n\ntype AccountsIndexes struct {\n    Number *indexes.Unique[uint64, sdk.AccAddress, authtypes.BaseAccount]\n}\n\nfunc (a AccountsIndexes) IndexesList() []collections.Index[sdk.AccAddress, authtypes.BaseAccount] {\n    return []collections.Index[sdk.AccAddress, authtypes.BaseAccount]{a.Number}\n}\n\nfunc NewAccountIndexes(sb *collections.SchemaBuilder) AccountsIndexes {\n    return AccountsIndexes{\n        Number: indexes.NewUnique(\n            sb, AccountsNumberIndexPrefix, "accounts_by_number",\n            collections.Uint64Key, sdk.AccAddressKey,\n            func(_ sdk.AccAddress, v authtypes.BaseAccount) (uint64, error) {\n                return v.AccountNumber, nil\n            },\n        ),\n    }\n}\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Accounts *collections.IndexedMap[sdk.AccAddress, authtypes.BaseAccount, AccountsIndexes]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewIndexedMap(\n            sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollValue[authtypes.BaseAccount](cdc),\n            NewAccountIndexes(sb),\n        ),\n    }\n}\n')),(0,a.kt)("h3",{id:"working-with-indexedmaps"},"Working with IndexedMaps"),(0,a.kt)("p",null,"Whilst instantiating ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.IndexedMap")," is tedious, working with them is extremely smooth."),(0,a.kt)("p",null,"Let's take the full example, and expand it with some use-cases."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package docs\n\nimport (\n    "cosmossdk.io/collections"\n    "cosmossdk.io/collections/indexes"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsNumberIndexPrefix = collections.NewPrefix(1)\n\ntype AccountsIndexes struct {\n    Number *indexes.Unique[uint64, sdk.AccAddress, authtypes.BaseAccount]\n}\n\nfunc (a AccountsIndexes) IndexesList() []collections.Index[sdk.AccAddress, authtypes.BaseAccount] {\n    return []collections.Index[sdk.AccAddress, authtypes.BaseAccount]{a.Number}\n}\n\nfunc NewAccountIndexes(sb *collections.SchemaBuilder) AccountsIndexes {\n    return AccountsIndexes{\n        Number: indexes.NewUnique(\n            sb, AccountsNumberIndexPrefix, "accounts_by_number",\n            collections.Uint64Key, sdk.AccAddressKey,\n            func(_ sdk.AccAddress, v authtypes.BaseAccount) (uint64, error) {\n                return v.AccountNumber, nil\n            },\n        ),\n    }\n}\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Accounts *collections.IndexedMap[sdk.AccAddress, authtypes.BaseAccount, AccountsIndexes]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey, cdc codec.BinaryCodec) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewIndexedMap(\n            sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollValue[authtypes.BaseAccount](cdc),\n            NewAccountIndexes(sb),\n        ),\n    }\n}\n\nfunc (k Keeper) CreateAccount(ctx sdk.Context, addr sdk.AccAddress) error {\n    nextAccountNumber := k.getNextAccountNumber()\n    \n    newAcc := authtypes.BaseAccount{\n        AccountNumber: nextAccountNumber,\n        Sequence:      0,\n    }\n    \n    return k.Accounts.Set(ctx, addr, newAcc)\n}\n\nfunc (k Keeper) RemoveAccount(ctx sdk.Context, addr sdk.AccAddress) error {\n    return k.Accounts.Remove(ctx, addr)\n} \n\nfunc (k Keeper) GetAccountByNumber(ctx sdk.Context, accNumber uint64) (sdk.AccAddress, authtypes.BaseAccount, error) {\n    accAddress, err := k.Accounts.Indexes.Number.MatchExact(ctx, accNumber)\n    if err != nil {\n        return nil, authtypes.BaseAccount{}, err\n    }\n    \n    acc, err := k.Accounts.Get(ctx, accAddress)\n    return accAddress, acc, nil\n}\n\nfunc (k Keeper) GetAccountsByNumber(ctx sdk.Context, startAccNum, endAccNum uint64) ([]authtypes.BaseAccount, error) {\n    rng := new(collections.Range[uint64]).\n        StartInclusive(startAccNum).\n        EndInclusive(endAccNum)\n    \n    iter, err := k.Accounts.Indexes.Number.Iterate(ctx, rng)\n    if err != nil {\n        return nil, err\n    }\n    \n    return indexes.CollectValues(ctx, k.Accounts, iter)\n}\n\n\nfunc (k Keeper) getNextAccountNumber() uint64 {\n    return 0\n}\n')),(0,a.kt)("h2",{id:"collections-with-interfaces-as-values"},"Collections with interfaces as values"),(0,a.kt)("p",null,"Although cosmos-sdk is shifting away from the usage of interface registry, there are still some places where it is used.\nIn order to support old code, we have to support collections with interface values."),(0,a.kt)("p",null,"The generic ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValue")," is not able to handle interface values, so we need to use a special type ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValueInterface"),".\n",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValueInterface")," takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.BinaryCodec")," as an argument, and uses it to marshal and unmarshal values as interfaces.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValueInterface")," lives in the ",(0,a.kt)("inlineCode",{parentName:"p"},"codec")," package, whose import path is ",(0,a.kt)("inlineCode",{parentName:"p"},"github.com/cosmos/cosmos-sdk/codec"),"."),(0,a.kt)("h3",{id:"instantiating-collections-with-interface-values"},"Instantiating Collections with interface values"),(0,a.kt)("p",null,"In order to instantiate a collection with interface values, we need to use ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValueInterface")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.CollValue"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package example\n\nimport (\n    "cosmossdk.io/collections"\n    storetypes "cosmossdk.io/store/types"\n    "github.com/cosmos/cosmos-sdk/codec"\n    sdk "github.com/cosmos/cosmos-sdk/types"\n    authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"\n)\n\nvar AccountsPrefix = collections.NewPrefix(0)\n\ntype Keeper struct {\n    Schema   collections.Schema\n    Accounts *collections.Map[sdk.AccAddress, sdk.AccountI]\n}\n\nfunc NewKeeper(cdc codec.BinaryCodec, storeKey *storetypes.KVStoreKey) Keeper {\n    sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n    return Keeper{\n        Accounts: collections.NewMap(\n            sb, AccountsPrefix, "accounts",\n            sdk.AccAddressKey, codec.CollInterfaceValue[sdk.AccountI](cdc),\n        ),\n    }\n}\n\nfunc (k Keeper) SaveBaseAccount(ctx sdk.Context, account authtypes.BaseAccount) error {\n    return k.Accounts.Set(ctx, account.GetAddress(), account)\n}\n\nfunc (k Keeper) SaveModuleAccount(ctx sdk.Context, account authtypes.ModuleAccount) error {\n    return k.Accounts.Set(ctx, account.GetAddress(), account)\n}\n\nfunc (k Keeper) GetAccount(ctx sdk.context, addr sdk.AccAddress) (sdk.AccountI, error) {\n    return k.Accounts.Get(ctx, addr)\n}\n')),(0,a.kt)("h2",{id:"triple-key"},"Triple key"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Triple")," is a special type of key composed of three keys, it's identical to ",(0,a.kt)("inlineCode",{parentName:"p"},"collections.Pair"),"."),(0,a.kt)("p",null,"Let's see an example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package example\n\nimport (\n "context"\n\n "cosmossdk.io/collections"\n storetypes "cosmossdk.io/store/types"\n "github.com/cosmos/cosmos-sdk/codec"\n)\n\ntype AccAddress = string\ntype ValAddress = string\n\ntype Keeper struct {\n // let\'s simulate we have redelegations which are stored as a triple key composed of\n // the delegator, the source validator and the destination validator.\n Redelegations collections.KeySet[collections.Triple[AccAddress, ValAddress, ValAddress]]\n}\n\nfunc NewKeeper(storeKey *storetypes.KVStoreKey) Keeper {\n sb := collections.NewSchemaBuilder(sdk.OpenKVStore(storeKey))\n return Keeper{\n  Redelegations: collections.NewKeySet(sb, collections.NewPrefix(0), "redelegations", collections.TripleKeyCodec(collections.StringKey, collections.StringKey, collections.StringKey)\n }\n}\n\n// RedelegationsByDelegator iterates over all the redelegations of a given delegator and calls onResult providing\n// each redelegation from source validator towards the destination validator.\nfunc (k Keeper) RedelegationsByDelegator(ctx context.Context, delegator AccAddress, onResult func(src, dst ValAddress) (stop bool, err error)) error {\n rng := collections.NewPrefixedTripleRange[AccAddress, ValAddress, ValAddress](delegator)\n return k.Redelegations.Walk(ctx, rng, func(key collections.Triple[AccAddress, ValAddress, ValAddress]) (stop bool, err error) {\n  return onResult(key.K2(), key.K3())\n })\n}\n\n// RedelegationsByDelegatorAndValidator iterates over all the redelegations of a given delegator and its source validator and calls onResult for each\n// destination validator.\nfunc (k Keeper) RedelegationsByDelegatorAndValidator(ctx context.Context, delegator AccAddress, validator ValAddress, onResult func(dst ValAddress) (stop bool, err error)) error {\n rng := collections.NewSuperPrefixedTripleRange[AccAddress, ValAddress, ValAddress](delegator, validator)\n return k.Redelegations.Walk(ctx, rng, func(key collections.Triple[AccAddress, ValAddress, ValAddress]) (stop bool, err error) {\n  return onResult(key.K3())\n })\n}\n')),(0,a.kt)("h2",{id:"advanced-usages"},"Advanced Usages"),(0,a.kt)("h3",{id:"alternative-value-codec"},"Alternative Value Codec"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"codec.AltValueCodec")," allows a collection to decode values using a different codec than the one used to encode them.\nBasically it enables to decode two different byte representations of the same concrete value.\nIt can be used to lazily migrate values from one bytes representation to another, as long as the new representation is\nnot able to decode the old one."),(0,a.kt)("p",null,"A concrete example can be found in ",(0,a.kt)("inlineCode",{parentName:"p"},"x/bank")," where the balance was initially stored as ",(0,a.kt)("inlineCode",{parentName:"p"},"Coin")," and then migrated to ",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"\nvar BankBalanceValueCodec = codec.NewAltValueCodec(sdk.IntValue, func(b []byte) (sdk.Int, error) {\n    coin := sdk.Coin{}\n    err := coin.Unmarshal(b)\n    if err != nil {\n        return sdk.Int{}, err\n    }\n    return coin.Amount, nil\n})\n")),(0,a.kt)("p",null,"The above example shows how to create an ",(0,a.kt)("inlineCode",{parentName:"p"},"AltValueCodec")," that can decode both ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.Int")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.Coin")," values. The provided\ndecoder function will be used as a fallback in case the default decoder fails. When the value will be encoded back into state\nit will use the default encoder. This allows to lazily migrate values to a new bytes representation."))}p.isMDXComponent=!0}}]);