"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[2880],{3905:(e,t,i)=>{i.d(t,{Zo:()=>p,kt:()=>m});var a=i(67294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,a,n=function(e,t){if(null==e)return{};var i,a,n={},r=Object.keys(e);for(a=0;a<r.length;a++)i=r[a],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)i=r[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(i),m=n,g=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return i?a.createElement(g,s(s({ref:t},p),{},{components:i})):a.createElement(g,s({ref:t},p))}));function m(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=i.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,s[1]=o;for(var c=2;c<r;c++)s[c]=i[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,i)}d.displayName="MDXCreateElement"},93084:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=i(87462),n=(i(67294),i(3905));const r={},s="ADR 048: Multi Tire Gas Price System",o={unversionedId:"architecture/adr-048-consensus-fees",id:"architecture/adr-048-consensus-fees",title:"ADR 048: Multi Tire Gas Price System",description:"Changelog",source:"@site/docs/architecture/adr-048-consensus-fees.md",sourceDirName:"architecture",slug:"/architecture/adr-048-consensus-fees",permalink:"/main/architecture/adr-048-consensus-fees",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ADR 047: Extend Upgrade Plan",permalink:"/main/architecture/adr-047-extend-upgrade-plan"},next:{title:"ADR 049: State Sync Hooks",permalink:"/main/architecture/adr-049-state-sync-hooks"}},l={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Multi-Tier Price System",id:"multi-tier-price-system",level:2},{value:"Extension Options",id:"extension-options",level:3},{value:"Tx Prioritization",id:"tx-prioritization",level:3},{value:"<code>min-gas-prices</code>",id:"min-gas-prices",level:3},{value:"Adjust For Block Load",id:"adjust-for-block-load",level:3},{value:"Block Segment Reservation",id:"block-segment-reservation",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Dos attack protection",id:"dos-attack-protection",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],p={toc:c};function u(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"adr-048-multi-tire-gas-price-system"},"ADR 048: Multi Tire Gas Price System"),(0,n.kt)("h2",{id:"changelog"},"Changelog"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Dec 1, 2021: Initial Draft")),(0,n.kt)("h2",{id:"status"},"Status"),(0,n.kt)("p",null,"Rejected"),(0,n.kt)("h2",{id:"abstract"},"Abstract"),(0,n.kt)("p",null,"This ADR describes a flexible mechanism to maintain a consensus level gas prices, in which one can choose a multi-tier gas price system or EIP-1559 like one through configuration."),(0,n.kt)("h2",{id:"context"},"Context"),(0,n.kt)("p",null,"Currently, each validator configures it's own ",(0,n.kt)("inlineCode",{parentName:"p"},"minimal-gas-prices")," in ",(0,n.kt)("inlineCode",{parentName:"p"},"app.yaml"),". But setting a proper minimal gas price is critical to protect network from dos attack, and it's hard for all the validators to pick a sensible value, so we propose to maintain a gas price in consensus level."),(0,n.kt)("p",null,"Since tendermint 0.34.20 has supported mempool prioritization, we can take advantage of that to implement more sophisticated gas fee system."),(0,n.kt)("h2",{id:"multi-tier-price-system"},"Multi-Tier Price System"),(0,n.kt)("p",null,"We propose a multi-tier price system on consensus to provide maximum flexibility:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Tier 1: a constant gas price, which could only be modified occasionally through governance proposal."),(0,n.kt)("li",{parentName:"ul"},"Tier 2: a dynamic gas price which is adjusted according to previous block load."),(0,n.kt)("li",{parentName:"ul"},"Tier 3: a dynamic gas price which is adjusted according to previous block load at a higher speed.")),(0,n.kt)("p",null,"The gas price of higher tier should bigger than the lower tier."),(0,n.kt)("p",null,"The transaction fees are charged with the exact gas price calculated on consensus."),(0,n.kt)("p",null,"The parameter schema is like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-protobuf"},"message TierParams {\n  uint32 priority = 1           // priority in tendermint mempool\n  Coin initial_gas_price = 2    //\n  uint32 parent_gas_target = 3  // the target saturation of block\n  uint32 change_denominator = 4 // decides the change speed\n  Coin min_gas_price = 5        // optional lower bound of the price adjustment\n  Coin max_gas_price = 6        // optional upper bound of the price adjustment\n}\n\nmessage Params {\n  repeated TierParams tiers = 1;\n}\n")),(0,n.kt)("h3",{id:"extension-options"},"Extension Options"),(0,n.kt)("p",null,"We need to allow user to specify the tier of service for the transaction, to support it in an extensible way, we add an extension option in ",(0,n.kt)("inlineCode",{parentName:"p"},"AuthInfo"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-protobuf"},"message ExtensionOptionsTieredTx {\n  uint32 fee_tier = 1\n}\n")),(0,n.kt)("p",null,"The value of ",(0,n.kt)("inlineCode",{parentName:"p"},"fee_tier")," is just the index to the ",(0,n.kt)("inlineCode",{parentName:"p"},"tiers")," parameter list."),(0,n.kt)("p",null,"We also change the semantic of existing ",(0,n.kt)("inlineCode",{parentName:"p"},"fee")," field of ",(0,n.kt)("inlineCode",{parentName:"p"},"Tx"),", instead of charging user the exact ",(0,n.kt)("inlineCode",{parentName:"p"},"fee")," amount, we treat it as a fee cap, while the actual amount of fee charged is decided dynamically. If the ",(0,n.kt)("inlineCode",{parentName:"p"},"fee")," is smaller than dynamic one, the transaction won't be included in current block and ideally should stay in the mempool until the consensus gas price drop. The mempool can eventually prune old transactions."),(0,n.kt)("h3",{id:"tx-prioritization"},"Tx Prioritization"),(0,n.kt)("p",null,"Transactions are prioritized based on the tier, the higher the tier, the higher the priority."),(0,n.kt)("p",null,"Within the same tier, follow the default Tendermint order (currently FIFO). Be aware of that the mempool tx ordering logic is not part of consensus and can be modified by malicious validator."),(0,n.kt)("p",null,"This mechanism can be easily composed with prioritization mechanisms:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"we can add extra tiers out of a user control:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Example 1: user can set tier 0, 10 or 20, but the protocol will create tiers 0, 1, 2 ... 29. For example IBC transactions will go to tier ",(0,n.kt)("inlineCode",{parentName:"li"},"user_tier + 5"),": if user selected tier 1, then the transaction will go to tier 15."),(0,n.kt)("li",{parentName:"ul"},"Example 2: we can reserve tier 4, 5, ... only for special transaction types. For example, tier 5 is reserved for evidence tx. So if submits a bank.Send transaction and set tier 5, it will be delegated to tier 3 (the max tier level available for any transaction). "),(0,n.kt)("li",{parentName:"ul"},"Example 3: we can enforce that all transactions of a sepecific type will go to specific tier. For example, tier 100 will be reserved for evidence transactions and all evidence transactions will always go to that tier.")))),(0,n.kt)("h3",{id:"min-gas-prices"},(0,n.kt)("inlineCode",{parentName:"h3"},"min-gas-prices")),(0,n.kt)("p",null,"Deprecate the current per-validator ",(0,n.kt)("inlineCode",{parentName:"p"},"min-gas-prices")," configuration, since it would confusing for it to work together with the consensus gas price."),(0,n.kt)("h3",{id:"adjust-for-block-load"},"Adjust For Block Load"),(0,n.kt)("p",null,"For tier 2 and tier 3 transactions, the gas price is adjusted according to previous block load, the logic could be similar to EIP-1559:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"def adjust_gas_price(gas_price, parent_gas_used, tier):\n  if parent_gas_used == tier.parent_gas_target:\n    return gas_price\n  elif parent_gas_used > tier.parent_gas_target:\n    gas_used_delta = parent_gas_used - tier.parent_gas_target\n    gas_price_delta = max(gas_price * gas_used_delta // tier.parent_gas_target // tier.change_speed, 1)\n    return gas_price + gas_price_delta\n  else:\n    gas_used_delta = parent_gas_target - parent_gas_used\n    gas_price_delta = gas_price * gas_used_delta // parent_gas_target // tier.change_speed\n    return gas_price - gas_price_delta\n")),(0,n.kt)("h3",{id:"block-segment-reservation"},"Block Segment Reservation"),(0,n.kt)("p",null,"Ideally we should reserve block segments for each tier, so the lower tiered transactions won't be completely squeezed out by higher tier transactions, which will force user to use higher tier, and the system degraded to a single tier."),(0,n.kt)("p",null,"We need help from tendermint to implement this."),(0,n.kt)("h2",{id:"implementation"},"Implementation"),(0,n.kt)("p",null,"We can make each tier's gas price strategy fully configurable in protocol parameters, while providing a sensible default one."),(0,n.kt)("p",null,"Pseudocode in python-like syntax:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"interface TieredTx:\n  def tier(self) -> int:\n    pass\n\ndef tx_tier(tx):\n    if isinstance(tx, TieredTx):\n      return tx.tier()\n    else:\n      # default tier for custom transactions\n      return 0\n    # NOTE: we can add more rules here per \"Tx Prioritization\" section \n\nclass TierParams:\n  'gas price strategy parameters of one tier'\n  priority: int           # priority in tendermint mempool\n  initial_gas_price: Coin\n  parent_gas_target: int\n  change_speed: Decimal   # 0 means don't adjust for block load.\n\nclass Params:\n    'protocol parameters'\n    tiers: List[TierParams]\n\nclass State:\n    'consensus state'\n    # total gas used in last block, None when it's the first block\n    parent_gas_used: Optional[int]\n    # gas prices of last block for all tiers\n    gas_prices: List[Coin]\n\ndef begin_block():\n    'Adjust gas prices'\n    for i, tier in enumerate(Params.tiers):\n        if State.parent_gas_used is None:\n            # initialized gas price for the first block\n              State.gas_prices[i] = tier.initial_gas_price\n        else:\n            # adjust gas price according to gas used in previous block\n            State.gas_prices[i] = adjust_gas_price(State.gas_prices[i], State.parent_gas_used, tier)\n\ndef mempoolFeeTxHandler_checkTx(ctx, tx):\n    # the minimal-gas-price configured by validator, zero in deliver_tx context\n    validator_price = ctx.MinGasPrice()\n    consensus_price = State.gas_prices[tx_tier(tx)]\n    min_price = max(validator_price, consensus_price)\n\n    # zero means infinity for gas price cap\n    if tx.gas_price() > 0 and tx.gas_price() < min_price:\n        return 'insufficient fees'\n    return next_CheckTx(ctx, tx)\n\ndef txPriorityHandler_checkTx(ctx, tx):\n    res, err := next_CheckTx(ctx, tx)\n    # pass priority to tendermint\n    res.Priority = Params.tiers[tx_tier(tx)].priority\n    return res, err\n\ndef end_block():\n    'Update block gas used'\n    State.parent_gas_used = block_gas_meter.consumed()\n")),(0,n.kt)("h3",{id:"dos-attack-protection"},"Dos attack protection"),(0,n.kt)("p",null,"To fully saturate the blocks and prevent other transactions from executing, attacker need to use transactions of highest tier, the cost would be significantly higher than the default tier."),(0,n.kt)("p",null,"If attacker spam with lower tier transactions, user can mitigate by sending higher tier transactions."),(0,n.kt)("h2",{id:"consequences"},"Consequences"),(0,n.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"New protocol parameters."),(0,n.kt)("li",{parentName:"ul"},"New consensus states."),(0,n.kt)("li",{parentName:"ul"},"New/changed fields in transaction body.")),(0,n.kt)("h3",{id:"positive"},"Positive"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The default tier keeps the same predictable gas price experience for client."),(0,n.kt)("li",{parentName:"ul"},"The higher tier's gas price can adapt to block load."),(0,n.kt)("li",{parentName:"ul"},"No priority conflict with custom priority based on transaction types, since this proposal only occupy three priority levels."),(0,n.kt)("li",{parentName:"ul"},"Possibility to compose different priority rules with tiers")),(0,n.kt)("h3",{id:"negative"},"Negative"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Wallets & tools need to update to support the new ",(0,n.kt)("inlineCode",{parentName:"li"},"tier")," parameter, and semantic of ",(0,n.kt)("inlineCode",{parentName:"li"},"fee")," field is changed.")),(0,n.kt)("h3",{id:"neutral"},"Neutral"),(0,n.kt)("h2",{id:"references"},"References"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1559"},"https://eips.ethereum.org/EIPS/eip-1559")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://iohk.io/en/blog/posts/2021/11/26/network-traffic-and-tiered-pricing/"},"https://iohk.io/en/blog/posts/2021/11/26/network-traffic-and-tiered-pricing/"))))}u.isMDXComponent=!0}}]);