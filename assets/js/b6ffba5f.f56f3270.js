"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[7417],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=i,u=m["".concat(c,".").concat(d)]||m[d]||h[d]||o;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},284:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_position:1},r="Blockchain Architecture",s={unversionedId:"intro/sdk-app-architecture",id:"version-v0.47/intro/sdk-app-architecture",title:"Blockchain Architecture",description:"State machine",source:"@site/versioned_docs/version-v0.47/intro/02-sdk-app-architecture.md",sourceDirName:"intro",slug:"/intro/sdk-app-architecture",permalink:"/v0.47/intro/sdk-app-architecture",draft:!1,tags:[],version:"v0.47",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Application-Specific Blockchains",permalink:"/v0.47/intro/why-app-specific"},next:{title:"Main Components of the Cosmos SDK",permalink:"/v0.47/intro/sdk-design"}},c={},l=[{value:"State machine",id:"state-machine",level:2},{value:"CometBFT",id:"cometbft",level:2},{value:"ABCI",id:"abci",level:2}],p={toc:l};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"blockchain-architecture"},"Blockchain Architecture"),(0,i.kt)("h2",{id:"state-machine"},"State machine"),(0,i.kt)("p",null,"At its core, a blockchain is a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/State_machine_replication"},"replicated deterministic state machine"),"."),(0,i.kt)("p",null,"A state machine is a computer science concept whereby a machine can have multiple states, but only one at any given time. There is a ",(0,i.kt)("inlineCode",{parentName:"p"},"state"),", which describes the current state of the system, and ",(0,i.kt)("inlineCode",{parentName:"p"},"transactions"),", that trigger state transitions."),(0,i.kt)("p",null,"Given a state S and a transaction T, the state machine will return a new state S'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+--------+                 +--------+\n|        |                 |        |\n|   S    +----------------\x3e+   S'   |\n|        |    apply(T)     |        |\n+--------+                 +--------+\n")),(0,i.kt)("p",null,"In practice, the transactions are bundled in blocks to make the process more efficient. Given a state S and a block of transactions B, the state machine will return a new state S'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+--------+                              +--------+\n|        |                              |        |\n|   S    +----------------------------\x3e |   S'   |\n|        |   For each T in B: apply(T)  |        |\n+--------+                              +--------+\n")),(0,i.kt)("p",null,"In a blockchain context, the state machine is deterministic. This means that if a node is started at a given state and replays the same sequence of transactions, it will always end up with the same final state."),(0,i.kt)("p",null,"The Cosmos SDK gives developers maximum flexibility to define the state of their application, transaction types and state transition functions. The process of building state-machines with the Cosmos SDK will be described more in depth in the following sections. But first, let us see how the state-machine is replicated using ",(0,i.kt)("strong",{parentName:"p"},"CometBFT"),"."),(0,i.kt)("h2",{id:"cometbft"},"CometBFT"),(0,i.kt)("p",null,"Thanks to the Cosmos SDK, developers just have to define the state machine, and ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.37/introduction/what-is-cometbft"},(0,i.kt)("em",{parentName:"a"},"CometBFT"))," will handle replication over the network for them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                ^  +-------------------------------+  ^\n                |  |                               |  |   Built with Cosmos SDK\n                |  |  State-machine = Application  |  |\n                |  |                               |  v\n                |  +-------------------------------+\n                |  |                               |  ^\nBlockchain node |  |           Consensus           |  |\n                |  |                               |  |\n                |  +-------------------------------+  |   CometBFT\n                |  |                               |  |\n                |  |           Networking          |  |\n                |  |                               |  |\n                v  +-------------------------------+  v\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.37/introduction/what-is-cometbft"},"CometBFT")," is an application-agnostic engine that is responsible for handling the ",(0,i.kt)("em",{parentName:"p"},"networking")," and ",(0,i.kt)("em",{parentName:"p"},"consensus")," layers of a blockchain. In practice, this means that CometBFT is responsible for propagating and ordering transaction bytes. CometBFT relies on an eponymous Byzantine-Fault-Tolerant (BFT) algorithm to reach consensus on the order of transactions."),(0,i.kt)("p",null,"The CometBFT ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.37/introduction/what-is-cometbft#consensus-overview"},"consensus algorithm")," works with a set of special nodes called ",(0,i.kt)("em",{parentName:"p"},"Validators"),". Validators are responsible for adding blocks of transactions to the blockchain. At any given block, there is a validator set V. A validator in V is chosen by the algorithm to be the proposer of the next block. This block is considered valid if more than two thirds of V signed a ",(0,i.kt)("inlineCode",{parentName:"p"},"prevote")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"precommit")," on it, and if all the transactions that it contains are valid. The validator set can be changed by rules written in the state-machine."),(0,i.kt)("h2",{id:"abci"},"ABCI"),(0,i.kt)("p",null,"CometBFT passes transactions to the application through an interface called the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.37/spec/abci/"},"ABCI"),", which the application must implement."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"              +---------------------+\n              |                     |\n              |     Application     |\n              |                     |\n              +--------+---+--------+\n                       ^   |\n                       |   | ABCI\n                       |   v\n              +--------+---+--------+\n              |                     |\n              |                     |\n              |       CometBFT      |\n              |                     |\n              |                     |\n              +---------------------+\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("strong",{parentName:"p"},"CometBFT only handles transaction bytes"),". It has no knowledge of what these bytes mean. All CometBFT does is order these transaction bytes deterministically. CometBFT passes the bytes to the application via the ABCI, and expects a return code to inform it if the messages contained in the transactions were successfully processed or not."),(0,i.kt)("p",null,"Here are the most important messages of the ABCI:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CheckTx"),": When a transaction is received by CometBFT, it is passed to the application to check if a few basic requirements are met. ",(0,i.kt)("inlineCode",{parentName:"li"},"CheckTx")," is used to protect the mempool of full-nodes against spam transactions. . A special handler called the ",(0,i.kt)("a",{parentName:"li",href:"/v0.47/basics/gas-fees#antehandler"},(0,i.kt)("inlineCode",{parentName:"a"},"AnteHandler"))," is used to execute a series of validation steps such as checking for sufficient fees and validating the signatures. If the checks are valid, the transaction is added to the ",(0,i.kt)("a",{parentName:"li",href:"https://docs.cometbft.com/v0.37/spec/p2p/messages/mempool"},"mempool")," and relayed to peer nodes. Note that transactions are not processed (i.e. no modification of the state occurs) with ",(0,i.kt)("inlineCode",{parentName:"li"},"CheckTx")," since they have not been included in a block yet."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DeliverTx"),": When a ",(0,i.kt)("a",{parentName:"li",href:"https://docs.cometbft.com/v0.37/spec/core/data_structures#block"},"valid block")," is received by CometBFT, each transaction in the block is passed to the application via ",(0,i.kt)("inlineCode",{parentName:"li"},"DeliverTx")," in order to be processed. It is during this stage that the state transitions occur. The ",(0,i.kt)("inlineCode",{parentName:"li"},"AnteHandler")," executes again, along with the actual ",(0,i.kt)("a",{parentName:"li",href:"/v0.47/building-modules/msg-services"},(0,i.kt)("inlineCode",{parentName:"a"},"Msg")," service")," RPC for each message in the transaction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BeginBlock"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"EndBlock"),": These messages are executed at the beginning and the end of each block, whether the block contains transactions or not. It is useful to trigger automatic execution of logic. Proceed with caution though, as computationally expensive loops could slow down your blockchain, or even freeze it if the loop is infinite.")),(0,i.kt)("p",null,"Find a more detailed view of the ABCI methods from the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cometbft.com/v0.37/spec/abci/"},"CometBFT docs"),"."),(0,i.kt)("p",null,"Any application built on CometBFT needs to implement the ABCI interface in order to communicate with the underlying local CometBFT engine. Fortunately, you do not have to implement the ABCI interface. The Cosmos SDK provides a boilerplate implementation of it in the form of ",(0,i.kt)("a",{parentName:"p",href:"/v0.47/intro/sdk-design#baseapp"},"baseapp"),"."))}h.isMDXComponent=!0}}]);