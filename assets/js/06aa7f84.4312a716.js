"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[9424],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},3620:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const o={},r="ADR 067: Simulator v2",l={unversionedId:"architecture/adr-067-simulator-v2",id:"architecture/adr-067-simulator-v2",title:"ADR 067: Simulator v2",description:"Changelog",source:"@site/docs/architecture/adr-067-simulator-v2.md",sourceDirName:"architecture",slug:"/architecture/adr-067-simulator-v2",permalink:"/main/architecture/adr-067-simulator-v2",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ADR-065: Store V2",permalink:"/main/architecture/adr-065-store-v2"},next:{title:"ADR {ADR-NUMBER}:",permalink:"/main/architecture/adr-template"}},s={},p=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Execution",id:"execution",level:3},{value:"Profiling",id:"profiling",level:3},{value:"Breakpoints",id:"breakpoints",level:3},{value:"Validity Predicates",id:"validity-predicates",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adr-067-simulator-v2"},"ADR 067: Simulator v2"),(0,i.kt)("h2",{id:"changelog"},"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"June 01, 2023: Initial Draft (@alexanderbez)")),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"DRAFT"),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"The Cosmos SDK simulator is a tool that allows developers to test the entirety\nof their application's state machine through the use of pseudo-randomized \"operations\",\nwhich represent transactions. The simulator also provides primitives that ensures\nthere are no non-determinism issues and that the application's state machine can\nbe successfully exported and imported using randomized state."),(0,i.kt)("p",null,"The simulator has played an absolutely critical role in the development and testing\nof the Cosmos Hub and all the releases of the Cosmos SDK after the launch of the\nCosmos Hub. Since the Hub, the simulator has relatively not changed much, so it's\noverdue for a revamp."),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,"The current simulator, ",(0,i.kt)("inlineCode",{parentName:"p"},"x/simulation"),", acts as a semi-fuzz testing suite that takes\nin an integer that represents a seed into a PRNG. The PRNG is used to generate a\nsequence of \"operations\" that are meant to reflect transactions that an application's\nstate machine can process. Through the use of the PRNG, all aspects of block production\nand consumption are randomized. This includes a block's proposer, the validators\nwho both sign and miss the block, along with the transaction operations themselves."),(0,i.kt)("p",null,"Each Cosmos SDK module defines a set of simulation operations that ",(0,i.kt)("em",{parentName:"p"},"attempt")," to\nproduce valid transactions, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"x/distribution/simulation/operations.go"),". These\noperations can sometimes fail depending on the accumulated state of the application\nwithin that simulation run. The simulator will continue to generate operations\nuntil it has reached a certain number of operations or until it has reached a\nfatal state, reporting results. This gives the ability for application developers\nto reliably execute full range application simulation and fuzz testing against\ntheir application."),(0,i.kt)("p",null,"However, there are a few major drawbacks. Namely, with the advent of ABCI++, specifically\n",(0,i.kt)("inlineCode",{parentName:"p"},"FinalizeBlock"),", the internal workings of the simulator no longer comply with how\nan application would actually perform. Specifically, operations are executed\n",(0,i.kt)("em",{parentName:"p"},"after")," ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalizeBlock"),", whereas they should be executed ",(0,i.kt)("em",{parentName:"p"},"within")," ",(0,i.kt)("inlineCode",{parentName:"p"},"FinalizeBlock"),"."),(0,i.kt)("p",null,"Additionally, the simulator is not very extensible. Developers should be able to\neasily define and extend the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consistency or validity predicates (what are known as invariants today)"),(0,i.kt)("li",{parentName:"ul"},"Property tests of state before and after a block is simulated")),(0,i.kt)("p",null,"In addition, we also want to achieve the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consolidated weight management, i.e. define weights within the simulator itself\nvia a config and not defined in each module"),(0,i.kt)("li",{parentName:"ul"},"Observability of the simulator's execution, i.e. have easy to understand output/logs\nwith the ability to pipe those logs into some external sink"),(0,i.kt)("li",{parentName:"ul"},"Smart replay, i.e. the ability to not only rerun a simulation from a seed, but\nalso the ability to replay from an arbitrary breakpoint"),(0,i.kt)("li",{parentName:"ul"},"Run a simulation based off of real network state")),(0,i.kt)("h2",{id:"decision"},"Decision"),(0,i.kt)("p",null,"Instead of refactoring the existing simulator, ",(0,i.kt)("inlineCode",{parentName:"p"},"x/simulation"),", we propose to create\na new package in the root of the Cosmos SDK, ",(0,i.kt)("inlineCode",{parentName:"p"},"simulator"),", that will be the new\nsimulation framework. The simulator will more accurately reflect the complete\nlifecycle of an ABCI application."),(0,i.kt)("p",null,"Specifically, we propose a similar implementation and use of a ",(0,i.kt)("inlineCode",{parentName:"p"},"simulator.Manager"),",\nthat exists today, that is responsible for managing the execution of a simulation.\nThe manager will wrap an ABCI application and will be responsible for the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Populating the application's mempool with a set of pseudo-random transactions\nbefore each block, some of which may contain invalid messages."),(0,i.kt)("li",{parentName:"ul"},"Selecting transactions and a random proposer to execute ",(0,i.kt)("inlineCode",{parentName:"li"},"PrepareProposal"),"."),(0,i.kt)("li",{parentName:"ul"},"Executing ",(0,i.kt)("inlineCode",{parentName:"li"},"ProcessProposal"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"FinalizeBlock")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Commit"),"."),(0,i.kt)("li",{parentName:"ul"},"Executing a set of validity predicates before and after each block."),(0,i.kt)("li",{parentName:"ul"},"Maintaining a CPU and RAM profile of the simulation execution."),(0,i.kt)("li",{parentName:"ul"},"Allowing a simulation to stop and resume from a given block height."),(0,i.kt)("li",{parentName:"ul"},"Simulation liveness of each validator per-block.")),(0,i.kt)("p",null,"From an application developer's perspective, they will only need to provide the\nmodules to be used in the simulator and the manager will take care of the rest.\nIn addition, they will not need to write their own simulation test(s), e.g.\nnon-determinism, multi-seed, etc..., as the manager will provide these as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Manager struct {\n  app     sdk.Application\n  mempool sdk.Mempool\n  rng     rand.Rand\n  // ...\n}\n")),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"The simulator's testing input will be driven by a configuration file, as opposed\nto CLI arguments. This will allow for more extensibility and ease of use along with\nthe ability to have shared configuration files across multiple simulations."),(0,i.kt)("h3",{id:"execution"},"Execution"),(0,i.kt)("p",null,"As alluded to previously, after the execution of each block, the manager will\ngenerate a series of pseudo-random transactions and attempt to insert them into\nthe mempool via ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseApp#CheckTx"),". During the ABCI lifecycle of a block, this\nmempool will be used to seed the transactions into a block proposal as it would\nin a real network. This allows us to not only test the state machine, but also\ntest the ABCI lifecycle of a block."),(0,i.kt)("p",null,"Statistics, such as total blocks and total failed proposals, will be collected,\nlogged and written to output after the full or partial execution of a simulation.\nThe output destination of these statistics will be configurable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (s *Simulator) SimulateBlock() {\n  rProposer := s.SelectRandomProposer()\n  rTxs := s.SelectTxs()\n\n  prepareResp, err := s.app.PrepareProposal(&abci.RequestPrepareProposal{Txs: rTxs})\n  // handle error\n\n  processResp, err := s.app.ProcessProposal(&abci.RequestProcessProposal{\n    Txs: prepareResp.Txs,\n    // ...\n  })\n  // handle error\n\n  // execute liveness matrix...\n\n  _, err = s.app.FinalizeBlock(...)\n  // handle error\n  \n  _, err = s.app.Commit(...)\n  // handle error\n}\n")),(0,i.kt)("p",null,"Note, some application do not define or need their own app-side mempool, so we\npropose that ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectTxs")," mimic CometBFT and just return FIFO-ordered transactions\nfrom an ad-hoc simulator mempool. In the case where an application does define\nits own mempool, it will simply ignore what is provided in ",(0,i.kt)("inlineCode",{parentName:"p"},"RequestPrepareProposal"),"."),(0,i.kt)("h3",{id:"profiling"},"Profiling"),(0,i.kt)("p",null,"The manager will be responsible for collecting CPU and RAM profiles of the simulation\nexecution. We propose to use ",(0,i.kt)("a",{parentName:"p",href:"https://pyroscope.io/docs/golang/"},"Pyroscope")," to\ncapture profiles and export them to a local file and via an HTTP endpoint. This\ncan be disabled or enabled by configuration."),(0,i.kt)("h3",{id:"breakpoints"},"Breakpoints"),(0,i.kt)("p",null,"Via configuration, a caller can express a height-based breakpoint that will allow\nthe simulation to stop and resume from a given height. This will allow for debugging\nof CPU, RAM, and state."),(0,i.kt)("h3",{id:"validity-predicates"},"Validity Predicates"),(0,i.kt)("p",null,"We propose to provide the ability for an application to provide the simulator a\nset of validity predicates, i.e. invariant checkers, that will be executed before\nand after each block. This will allow for the application to assert that certain\nstate invariants are held before and after each block. Note, as a consequence of\nthis, we propose to remove the existing notion of invariants from module production\nexecution paths and deprecate their usage all together."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Manager struct {\n  // ...\n  preBlockValidator   func(sdk.Context) error\n  postBlockValidator  func(sdk.Context) error\n}\n")),(0,i.kt)("h2",{id:"consequences"},"Consequences"),(0,i.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,i.kt)("p",null,"The new simulator package will not naturally not be backwards compatible with the\nexisting ",(0,i.kt)("inlineCode",{parentName:"p"},"x/simulation")," module. However, modules will still be responsible for\nproviding pseudo-random transactions to the simulator."),(0,i.kt)("h3",{id:"positive"},"Positive"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Providing more intuitive and cleaner APIs for application developers"),(0,i.kt)("li",{parentName:"ul"},"More closely resembling the true lifecycle of an ABCI application")),(0,i.kt)("h3",{id:"negative"},"Negative"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Breaking current Cosmos SDK module APIs for transaction generation")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/osmosis-labs/osmosis/blob/main/simulation/ADR.md"},"Osmosis Simulation ADR"))))}u.isMDXComponent=!0}}]);